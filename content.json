[{"title":"3.7 输入与输出","date":"2021-05-08T12:06:00.000Z","path":"2021/05/08/coreJava1/3.7.1 读取输入/","text":"3.7.1 读取输入 通过控制台进行输入的步骤： 首先构造一个与“标准输入流”System.in关联的Scanner对象： Scanner in = new Scanner(); 使用Scanner类的各种方法读取输入： String name = in.nextLine(); Scanner类定义在java.util包中，使用时要用import导入。 Scanner类的常用方法 String nextLine():将读取一行输入 。 String next():读取输入的下一个单词（以空格作为分隔符）。 int nextInt() Consle类 Scanner类不适用于从控制台读取密码，此时可以用Consle类。 1234Consle cons = System.console();String username = cons.readLine(&quot;User name: &quot;);char[] passwd = cons.readPassword(&quot;Password: &quot;); 代码 12345678910111213141516171819202122232425262728import java.util.*;/** * This program demonstrates console input * @version 1.10 2021-05-08 * @author 文进 * */public class InputTest &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); // get first input System.out.print(&quot;What is your name? &quot;); String name = in.nextLine(); // get second input System.out.print(&quot;How old are you? &quot;); int age = in.nextInt(); // display output on console System.out.println(&quot;Hello, &quot; + name + &quot;.Next year, you&#x27;ll be &quot; + (age + 1)); &#125;&#125; 3.7.2 格式化输出 System.out.print(x);将以x的类型所允许的最大非0数位个数打印输出x。 System.out.print(&quot;%8.2f&quot;, x);字段宽度为8，包括8个字符，另外精度为小数点后2个字符，注意这里前导的空格也算一个字符。 每一个以%字符开始的格式说明符都用相应的参数替换。如：System.out.printf(&quot;Hello, %s. Next year, you'll be %d.&quot;,name, age + 1);,f表示浮点数，s表示字符串，d表示十进制整数。 还可以指定控制格式化输出外观的各种标志，如：System.out.printf(&quot;%,.2f&quot;, 10000.0 / 3.0); //prints 3,333.33 使用静态的String.format方法创建一个格式化的字符串，而不打印输出：String message = String.format(&quot;Hello, %s. Next year, you'll be %d.&quot;, name, age + 1); printf方法中有日期与时间格式化选项，如System.out.printf(&quot;%tc&quot;, new Date()); // prints 周六 5月 08 20:44:49 CST 2021 3.7.3 文件输入与输出 读取文件：Scanner in = new Scanner(Path.of(&quot;myfile.txt&quot;), StandardCharsets.UTF-8); 写入文件：PrintWriter out = new PrintWriter(&quot;myfile.txt&quot;, StandardCharsets.UTF_8);","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"《Java核心技术卷I 基础知识》","slug":"《Java核心技术卷I-基础知识》","permalink":"http://example.com/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%8B/"}]},{"title":"118.杨辉三角","date":"2021-05-08T11:25:09.000Z","path":"2021/05/08/LeetCode/118.杨辉三角/","text":"官方链接 题目描述 官方解答 题目描述 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 题解思路 在杨辉三角中，每个数是它左上方和右上方的数的和，根据这一点，可以先生成第iii行的元素，再生成第i+1i+1i+1行的元素。 代码 123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i = 0; i &lt; numRows; i++)&#123; List&lt;Integer&gt; row = new ArrayList&lt;Integer&gt;(); for(int j = 0; j &lt;= i; j++)&#123; if(j == 0 || j == i)&#123; row.add(1); &#125; else&#123; row.add(ret.get(i - 1).get(j - 1) + ret.get(i - 1).get(j)); &#125; &#125; ret.add(row); &#125; return ret; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"}]},{"title":"1468.数组异或操作","date":"2021-05-07T02:49:09.000Z","path":"2021/05/07/LeetCode/1468.数组异或操作/","text":"官方链接 1468.数组异或操作 题目描述 给你两个整数，n 和 start 。 数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。 请返回 nums 中所有元素按位异或（XOR）后得到的结果。 示例 1： 1234输入：n &#x3D; 5, start &#x3D; 0输出：8解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) &#x3D; 8 。 &quot;^&quot; 为按位异或 XOR 运算符。 示例 2： 123输入：n &#x3D; 4, start &#x3D; 3输出：8解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) &#x3D; 8. 示例 3： 12输入：n &#x3D; 1, start &#x3D; 7输出：7 示例 4： 12输入：n &#x3D; 10, start &#x3D; 5输出：2 提示： 1 &lt;= n &lt;= 1000 0 &lt;= start &lt;= 1000 n == nums.length 题解思路 异或运算规则为相同为0，相异为1. 可以遍历每一个元素，依次做异或运算。 代码 1234567891011class Solution &#123; public int xorOperation(int n, int start) &#123; int result = start; for(int i = 1; i &lt; n; i++) &#123; result = result ^ (start + 2 * i); &#125; return result; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"1720.解码异或后的数组","date":"2021-05-06T03:08:09.000Z","path":"2021/05/06/LeetCode/1720.解码异或后的数组/","text":"官方链接 1720.解码异或后的数组 题目描述 未知 整数数组 arr 由 n 个非负整数组成。 经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。 给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。 请解码返回原数组 arr 。可以证明答案存在并且是唯一的。 示例 1： 123输入：encoded &#x3D; [1,2,3], first &#x3D; 1输出：[1,0,2,1]解释：若 arr &#x3D; [1,0,2,1] ，那么 first &#x3D; 1 且 encoded &#x3D; [1 XOR 0, 0 XOR 2, 2 XOR 1] &#x3D; [1,2,3] 示例 2： 12输入：encoded &#x3D; [6,2,7,3], first &#x3D; 4输出：[4,2,0,7,4] 提示： 2 &lt;= n &lt;= 104 encoded.length == n - 1 0 &lt;= encoded[i] &lt;= 10510^5105 0 &lt;= first &lt;= 10510^5105 题解思路 在异或运算中，相同为0，相异为1，即 0⊕0=01⊕0=11⊕1=00⊕1=10 \\oplus 0 = 0 \\\\ 1 \\oplus 0 = 1 \\\\ 1 \\oplus 1 = 0 \\\\ 0 \\oplus 1 = 1 0⊕0=01⊕0=11⊕1=00⊕1=1 根据题意，我们现在得到的是异或后的结果，也就是上面异或运算法则等号后的数，即第三列。由于知道原来数组中的第一个元素，可以理解为知道上述异或运算法则的第一列，现在看如何知道第二列。设这个运算为新异或运算，标记为⊕′\\oplus&#x27;⊕′，则有规则如下： 0⊕′0=01⊕′1=00⊕′1=11⊕′0=10 \\oplus&#x27; 0 = 0\\\\ 1 \\oplus&#x27; 1 = 0\\\\ 0 \\oplus&#x27; 1 = 1\\\\ 1 \\oplus&#x27; 0 = 1 0⊕′0=01⊕′1=00⊕′1=11⊕′0=1 在上述法则中，可以发现规律，相同为0，不同为1，从而得到⊕′\\oplus&#x27;⊕′为异或运算。因此解码过程为逐个进行异或运算。 在Java中，a与b的异或为a^b。 代码 12345678910111213class Solution &#123; public int[] decode(int[] encoded, int first) &#123; int n = encoded.length; int[] ans = new int[n + 1]; ans[0] = first; for(int i = 0; i &lt; n; i++) &#123; ans[i+1] = ans[i] ^ encoded[i]; &#125; return ans; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"633.平方数之和","date":"2021-04-28T11:56:09.000Z","path":"2021/04/28/LeetCode/633.平方数之和/","text":"官方链接 题目描述 官方题解 题目描述 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2+b2=ca^2 + b^2 = ca2+b2=c。 示例 1： 123输入：c &#x3D; 5输出：true解释：1 * 1 + 2 * 2 &#x3D; 5 示例 2： 12输入：c &#x3D; 3输出：false 示例 3： 12输入：c &#x3D; 4输出：true 示例 4： 12输入：c &#x3D; 2输出：true 示例 5： 12输入：c &#x3D; 1输出：true 提示： 0≤c≤231−10 \\le c \\le 2^{31} - 10≤c≤231−1 题解思路 所给的非负整数为ccc，那么要找的两个数aaa和bbb的范围肯定为[0,c][0,\\sqrt{c}][0,c​]。首先第一个整数aaa在[0,c][0,\\sqrt{c}][0,c​]之间遍历，当aaa确定后，b=c2−a2b=\\sqrt{c^2-a^2}b=c2−a2​，再确定整数bbb，在这个过程中，有可能需要强制转换类型，会直接截断，因此还需要进一步检验，如果有c=a2+b2c=a^2+b^2c=a2+b2，则返回true。 时间复杂度：O(c)O(\\sqrt{c})O(c​) 空间复杂度：O(1)O(1)O(1) 代码实现 123456789101112class Solution &#123; public boolean judgeSquareSum(int c) &#123; int n = (int)Math.sqrt(c); for(int i = n; i &gt;= 0; i--) &#123; int tempt = (int)Math.sqrt(c - i * i); if(tempt * tempt + i * i == c) &#123; return true; &#125; &#125; return false; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode中等","slug":"LeetCode中等","permalink":"http://example.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"1101.在D天内送达包裹的能力","date":"2021-04-28T11:04:09.000Z","path":"2021/04/28/LeetCode/1101.在D天内送达包裹的能力/","text":"官网链接 题目 官方解答 题目描述 传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。 传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。 返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。 示例 1： 1234567891011输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5输出：15解释：船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：第 1 天：1, 2, 3, 4, 5第 2 天：6, 7第 3 天：8第 4 天：9第 5 天：10请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 示例 2： 1234567输入：weights &#x3D; [3,2,2,4,1,4], D &#x3D; 3输出：6解释：船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：第 1 天：3, 2第 2 天：2, 4第 3 天：1, 4 示例 3： 1234567输入：weights &#x3D; [1,2,3,1,1], D &#x3D; 4输出：3解释：第 1 天：1第 2 天：2第 3 天：3第 4 天：1, 1 提示： 121 &lt;&#x3D; D &lt;&#x3D; weights.length &lt;&#x3D; 500001 &lt;&#x3D; weights[i] &lt;&#x3D; 500 题解思路 二分查找的思想，根据题目的描述，可以确定合适的船运载量应该在区间[weights中最大元素，weights所有元素之和]，设二分区间为[left,right]。现在需要计算对于船运载量为xxx时，所需的天数是多少，用needDay表示。不断二分区间[left,right]，计算needDay，与所要求的天数D进行比较。 如果needDay &gt; D，说明当前运载量小了，合适的运载量在区间[mid + 1, right],需要让left = mid + 1。 如果needDay &lt;= D,说明当前运载量大了或者合适，合适的运载量在区间[left, mid],需要让right = mid。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package leetcode;import java.util.Arrays;import java.util.Scanner;public class CapacityToShipPackagesWithinDDays &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int D = in.nextInt(); int n = in.nextInt(); int[] weights = new int[n]; for(int i = 0; i &lt; n; i++) &#123; weights[i] = in.nextInt(); &#125; Solution s = new Solution (); System.out.println(s.shipWithinDays(weights, D)); &#125;&#125;class Solution &#123; public int shipWithinDays(int[] weights, int D) &#123; // 确定二分查找左右边界 int left = Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum(); while(left &lt; right) &#123; int mid = (left + right) / 2; // need 为需要运送的天数 // cur 为当前这一天已经运算的包裹重量之和 int need = 1, cur = 0; for(int weight : weights) &#123; if(cur + weight &gt; mid) &#123; ++need; cur = 0; &#125; cur += weight; &#125; if(need &lt;= D) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"LeetCode中等","slug":"LeetCode中等","permalink":"http://example.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"}]},{"title":"LeetCode题目汇总","date":"2021-04-28T11:01:09.000Z","path":"2021/04/28/LeetCode/LeetCode题目汇总/","text":"118.杨辉三角 #简单 #数组 633.平方数之和 #中等 #数学 1101.在D天内送达包裹的能力 #中等 #二分查找 1468.数组异或操作 #简单 #位运算 #数组 1720.解码异或后的数组 #简单 #位运算","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"题目汇总","slug":"题目汇总","permalink":"http://example.com/tags/%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"}]},{"title":"3.5运算符-3.6字符串","date":"2021-04-16T13:06:00.000Z","path":"2021/04/16/coreJava1/3.5运算符-3.6字符串/","text":"3.5 运算符 3.5.1 算术运算符 算术运算符+、-、*、/表示加、减、乘、除运算。 当参与/运算的两个操作数都是整数时，表示整数除法，否则，表示浮点除法。 整数的求余操作%。 整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或NaN结果。 3.5.2 数学函数与常量 Math类中的sqrt方法并不处理任何对象，这样的方法被称为静态方法。 pow方法有两个double类型的参数，其返回结果也为double类型。 12345678910public class UseMath &#123; public static void main(String[] args) &#123; double x = 4; double y = Math.sqrt(x); double z = Math.pow(x, 2); System.out.println(y); // prints 2.0 System.out.println(z); // prints 16.0 &#125;&#125; 也可以在源文件的顶部加上import static java.lang.Math.*;。 1234567891011import static java.lang.Math.*;public class UseMath &#123; public static void main(String[] args) &#123; double x = 4; double y = sqrt(x); double z = pow(x, 2); System.out.println(y); // prints 2.0 System.out.println(z); // prints 16.0 &#125;&#125; floorMod方法的目的是解决一个长期存在的有关整数余数的问题。考虑表达式n%2，如果n为负且为奇数，这个表达式则为-1。实际上根据欧几里得规则，余数总是要≥0\\ge0≥0。floorMod(position + adjustment, 12)总会得到一个0~11之间的数。（遗憾的是，对于负除数，floorMod会得到负数结果，不过这种情况在实际中很少出现。） 三角函数： 12345Math.sinMath.cosMath.tanMath.atanMath.atan2 指数函数及它的反函数 123Math.expMath.logMath.log10 Java提供两个用于表示π\\piπ和eee常量的最接近的近似值： 12Math.PIMath.E 3.5.3 数值类型之间的转换 当用一个二元运算符连接两个值时，先要将两个操作数转换为同一种类型，然后再进行计算。 3.5.4 强制类型转换 强制类型转换的语法格式是在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名。 强制类型转换是通过截断小数部分将浮点值转换为整型。 对浮点数进行舍入运算时，需要使用Math.round方法。当调用round的时候，仍然需要使用强制类型转换(int)。原因是round方法返回的结果为long类型，由于存在信息丢失的可能性，所以只有使用显式的强制类型转换才能够将long类型转换成int类型。 12345double xx = 9.997;int nxx = (int) xx;System.out.println(nxx); // prints 9int nxx2 = (int) Math.round(xx);System.out.println(nxx2); // prints 10 如果试图将一个数值从一种类型强制转换为另一种类型，而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值。如(byte)300的实际值为44。 3.5.5 结合赋值和运算符 可以在赋值中运用二元运算符，如x += 4;等价于x = x + 4;。 如果运算符得到一个值，其类型与左侧操作数的类型不同，就会发生强制类型转换。如果x是一个int，则x += 3.5;等价于x = (int)(x + 3.5);。 3.5.6 自增与自减运算符 自增运算符：n++，自减运算符：n–。 自增运算符还有一种“前缀”形式：++n。 后缀和前缀形式都会使变量值加1或减1。但用在表达式中时，二者就有区别了。前缀形式会先完成加1；而后缀形式会使用变量原来的值。 建议不要在表达式中使用++，因为这样的代码很容易让人困惑，而且会带来烦人的bug。 3.5.7 关系和boolean运算符 &amp;&amp;和||运算符是按照“短路”方式来求值的。 x != 0 &amp;&amp; 1 / x &gt; x + y // no division by 0，如果x等于0，那么第二部分就不会计算，除以0的错误就不会出现。 Java支持三元操作符?:，例如x &lt; y ? x : y返回x和y中较小的一个。 3.5.8 位运算符 如果n是一个整数变量，而且用二进制表示的n从右边数第4位为1，则int fourthBitFromRight = (n &amp; 0b1000) / 0b1000;会返回1，否则返回0. 利用&amp;并结合适当的2的幂，可以把其他位掩掉，而只留下其中的某一位。 &amp;和|运算符不采用“短路”方式求值。 需要建立位模式来完成掩码时，&gt;&gt;和&lt;&lt;运算符会很方便，int fourthBitFromRight = (n &amp; (1 &lt;&lt; 3)) &gt;&gt; 3;。 &gt;&gt;&gt;运算符会用0填充高位，这与&gt;&gt;不同，它会用符号位填充高位。 3.5.9 括号与运算符级别 注意+=是右结合运算符。 3.6 字符串 从概念上讲，Java字符串就是Unicode字符序列。 每个双引号括起来的字符串都是String类的一个实例。 3.6.1 子串 String类的substring方法可以从一个较大的字符串中提取出一个子串。 12345678public class SubString &#123; public static void main(String[] args) &#123; String greeting = &quot;Hello&quot;; String s = greeting.substring(0, 3); System.out.println(s); // prints Hel &#125;&#125; substring方法的第二个参数是不想复制的第一个位置。这样的工作方式有一个优点，容易计算子串的长度。字符串s.substring(a,b)的长度为b-a。 3.6.2 拼接 Java语言允许使用+号连接两个字符串。 当一个字符串与一个非字符串的值进行拼接时，后者会转换成字符串。 如果需要把多个字符串放在一起，用一个界定符分隔，可以使用静态join方法。 在Java11中，提供了一个repeat方法。 12System.out.println(String.join(&quot;/&quot;, &quot;S&quot;, &quot;M&quot;, &quot;L&quot;)); // prints S/M/LSystem.out.println(&quot;Java&quot;.repeat(3)); // prints JavaJavaJava 3.6.3 不可变字符串 如何修改字符串？可以提取想要保留的子串，再与希望替换的字符拼接,greeting = greeting.substring(0, 3) + &quot;p!&quot;;。 由于不能修改Java字符串中的单个字符，所以在Java文档中将String类对象称为是不可变的，但是，可以修改字符串变量。 不可变字符串有一个优点：编译器可以让字符串共享。 3.6.4 检测字符串是否相等 s.equals(t)检测两个字符串是否相等，s与t可以是字符串变量，也可以是字符串字面量，例如&quot;Hello&quot;.equals(greeting)。 检测两个字符串是否相等，而不区分大小写 1&quot;Hello&quot;.equalsIgnoreCase(&quot;hello&quot;) 一定不要使用==运算检测两个字符串是否相等！这个运算符只能够确定两个字符串是否存放在同一个位置上。 3.6.5 空串与Null串 空串&quot;&quot;是长度为0的字符串，有自己的串长度（0）和内容（空）。检查一个字符串是否为空： 1if(str.length() == 0) 1if(str.equals(&quot;&quot;)) null，表示目前没有任何对象与该变量关联。检查一个字符串是否为null： 1if(str == null) 检查一个字符串既不是null也不是空串，需要首先检查str不为null。 1if(str != null &amp;&amp; str.length() != 0) 3.6.6 码点与代码单元 要想得到实际的长度，即码点数量，可以调用： 1int cpCount = greeting.codePointCount(0, greeting.length()); 3.6.9 构建字符串 如果需要许多小段的字符串来构建一个字符串，按照下列步骤进行。 1234StringBuilder builder = new StringBuilder();builder.append(ch); // appends a single characterbuilder.append(str); // appends a stringString completedString = builder.toString();","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"《Java核心技术卷I 基础知识》","slug":"《Java核心技术卷I-基础知识》","permalink":"http://example.com/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%8B/"}]},{"title":"3.1一个简单的Java应用程序-3.4 变量与常量","date":"2021-04-16T04:05:00.000Z","path":"2021/04/16/coreJava1/3.1一个简单的Java应用程序-3.4 变量与常量/","text":"3.1 一个简单的Java应用程序 123456public class FirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;We will not use &#x27;Hello, World!&quot;); &#125;&#125; Java是区分大小写的。 public为访问修饰符，用于控制程序的其他部分对这段代码的访问级别。 在Java中，应用程序中的全部内容都必须放置在类中。 类名的规则：名字必须以字母开头，后面可以跟字母和数字的任意组合，长度没有限制，但是不能使用Java保留字。 类名的命名方法，可采用骆驼命名法，类名以大写字母开头，如果名字由多个单词组成，每个单词的第一个字母应该大写，如CameClass。 Java虚拟机总是从指定类中的main方法的代码开始执行的。 每个Java应用程序都必须有一个main方法，声明格式如下 1234567public class ClassName&#123; public static void main(String[] args) &#123; program statements &#125;&#125; 在Java中一对大括号表示方法体的开始与结束，每个句子必须使用分号结束。 System.out.print(&quot;Hello&quot;)输出之后不增加换行符。 3.2 注释 Java中有三种注释方法： 使用//，注释内容从//开始到本行结尾。 使用/*和*/，这之间均为注释内容，可以注释更长的内容。 文档注释，以/**开始，以*/结束。 12345678910111213/** * This is the first sample program in Core Java CHapter 3 * @version 1.01 1997-03-22 * @author Gary Cornell */package firstsample;public class FirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;We will not use &#x27;Hello, World!&quot;); &#125;&#125; 3.3 数据类型 Java是一种强类型语言。在Java中，有8种基本数据类型，其中有4种整型、2种浮点类型、1种字符类型和1种用于表示真值的boolean类型。 3.3.1 整型 整型有4种类型。 类型 存储需求 取值范围 int 4字节 -2 147 483 648 ~ 2 147 483 647（刚刚超过20亿） short 2字节 -32 768 ~ 32 767 long 8字节 -9 223 372 036 854 775 808~9 223 372 036 854 775 807 byte 1字节 -128~127 byte和short类型主要用于特定的应用场合。 长整型数值有一个后缀L或l。例如如果直接运行System.out.println(4000000000000);会出现错误，提示The literal 4000000000000 of type int is out of range，这时要用到长整型数System.out.println(4000000000000L);。 十六进制数值有一个前缀0X或0x。 八进制有一个前缀0。 从Java7开始，加上前缀0b或0B可以写二进制。 3.3.2 浮点类型 Java中有两种浮点类型。 类型 存储需求 取值范围 float 4字节 大约 $\\pm$3.402 823 47E+38F(有效位数为6~7位) double 8字节 大约 $\\pm$1.797 693 134 862 315 70E+308(有效位数为15位) 实际上，只有很少的情况适合使用float类型，例如，需要单精度数的库，或者需要大量存储数据时。 float类型的数值有一个后缀F或f。没有后缀F的浮点数总是默认为double类型。 用于表示溢出和出错情况的三个特殊的浮点数值：正无穷大Double.POSITIVE_INFINITY、负无穷大Double.NEGATIVE_INFINITY、NaN（不是一个数字，常量表示为Double.NaN）。 检测一个特定值是否等于Double.NaN:if(Double.isNaN(x)) // check whether x is &quot;not a number&quot;。 特别注意：浮点数值不适用与无法接受舍入误差的金融计算，原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确地表示分数1/10。 3.3.3 char类型 char类型原本用于表示单个字符，如今，有些Unicode字符可以用一个或两个char值描述。 char类型的字面量值要用单引号括起来，例如‘A’是编码值为65的字符常量。 转义序列\\u还可以出现在加引号的字符常量和字符串之外（而其他所有的转义序列不可以）。 Unicode转义序列会在解析代码之前得到处理，因此一定要当心注释中的\\u。如// \\u000A is a newline会报错。 3.3.4 Unicode和char类型 不同编码机制产生了两个问题：一是对于任意给定的代码值，在不同的编码方案下有可能对应不同的字母；而是采用大字符集的语言其编码长度有可能不同。 在Java中，char类型描述了UTF-16编码中的一个代码单元。 强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。 3.3.5 boolean类型 boolean类型有两个值：false和true，用来判定逻辑条件。 整型值和布尔值之间不能进行转换。 3.4 变量与常量 3.4.1 声明变量 在Java中，每个变量都有一个类型。 声明变量的例子： 1234double salary;int vacationDays;long earthPopulation;boolean done; 变量名必须是一个以字母开头并由字母和数字构成的序列。 在Java中，“字母”和“数字”的范围更大。字母包括‘A’~‘Z’、‘a’~‘z’、‘_’、‘$’或在某种语言中表示字母的任何Unicode字符。数字包括‘0’~‘9’和在某种语言中表示数字的任何Unicode字符。 变量中所有字符都是有意义的，并且大小写敏感。 如果想知道哪些Unicode字符属于Java中的“字母”，可以使用Character类的isJavaIdentifierStart和isJavaIdentifierPart方法来检查。 不能使用Java保留字作为变量名。 在Java9中，单下划线不能作为变量名。 逐一声明每一个变量可以提高程序的可读性。 3.4.2 变量初始化 声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量的值。 有两种方式进行变量初始化： 12int vacationDays;vacationDays = 12; 1int vacationDays = 12; 在Java中可以将声明放在代码中的任何地方。 在Java中，变量的声明尽可能地靠近变量第一次使用的地方，这是一种良好的程序编程风格。 从Java10开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不再需要声明类型。只需要使用关键字var而无须指定类型。 1var vacationDays = 12; // vacationDays is an int 3.4.3 常量 关键字final表示这个变量只能被赋值一次。一旦赋值之后，就不能够再更改了。习惯上，常量名使用全大写。 12345678910 public class Constants &#123; public static void main(String[] args) &#123; final double CM_PER_INCH = 2.54; double paperWidth = 8.5; double paperHeight = 11; System.out.println(&quot;Paper size in centimeters: &quot; + paperWidth * CM_PER_INCH + &quot; by &quot; + paperHeight * CM_PER_INCH); &#125;&#125; 类常量，可以在一个类的多个方法中使用，使用关键字static final设置一个类常量。 1234567891011public class Constants2 &#123; public static final double CM_PER_INCH = 2.54; public static void main(String[] args) &#123; double paperWidth = 8.5; double paperHeight = 11; System.out.println(&quot;Paper size in centimeters: &quot; + paperWidth * CM_PER_INCH + &quot; by &quot; + paperHeight * CM_PER_INCH); &#125;&#125; 类常量的定义位于main方法的外部。如果一个类常量被声明为public，那么其他类的方法也可以使用这个常量。 3.4.4 枚举类型 枚举类型包括有限个命名的值。例如enum Size &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;。 Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者特殊值null，null表示这个变量没有设置任何值。 书籍信息 《Java核心技术卷I 基础知识》","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"《Java核心技术卷I 基础知识》","slug":"《Java核心技术卷I-基础知识》","permalink":"http://example.com/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%8B/"}]},{"title":"《算法》笔记1-1.1 Basic Programming Model","date":"2021-04-05T11:18:09.000Z","path":"2021/04/05/《算法》/《算法》笔记1-1.1 Basic Programming Model/","text":"Chapter 1 Fundamentals abstract data types(ADTs) applications programming interface(API) 1.1 Basic Programming Model Expressions (P13) 操作数之间的优先级 Java语言中：*和/（和%）比+和-的优先级高. 逻辑操作数中：!拥有最高优先级，接着是&amp;&amp;和||. 一般而言，相同优先级的操作数遵循从左到右的优先级。 由于在语言之间优先级有轻微的差别，可以使用括号来避免。 Type conversion（类型转换）(P13) Numbers are automatically promoted to a more inclusive type if no information is lost. 在没有信息丢失的情况下，数字自动提高到一个包含更多的类型。 A cast is a type name in parentheses within an expression… 可以在表达式中加括号进行类型转换，例如(int) 3.7，结果为3。 Note that casting to an int is truncation instead of rounding… 特别注意的一点：转换为int类型时是截断而不是凑整。 A best practice is to use expressions that involve literals or variables of a single type. Comparisons (P13) 比较两个相同类型的值，返回一个布尔值。 name operator equal == not equal != less than &lt; less than or equal &lt;= greater than &gt; greater than or equal &gt;= Other primmitive types (P13) 64-bit integers, with arithmetic operations(long) 16-bit integers, with arithmetic operations(short) 16-bit characters, with arithmetic operations(char) 8-bit intergers, with arithmetic operations(byte) 32-bit single-precision real numbers, again with arithmetic operations(float) Implict assignments (P16) i++与++i的区别？ a = i++ 它等价于 a = i ; i = i + 1; a = ++i 它等价于 i = i + 1; a = i; Creating and initalizing an array (P18) 创建一个数组包括以下三个步骤，缺一不可: Declare the array name and type. Create the array. Initialize the array values. long term 1234double[] a;a = new double[N];for(int i = 0; i &lt; N; i++) a[i] = 0.0; short term 1double[] a = new double[N]; intializing declaration 1int[] a = &#123;1, 2, 5, 7, 8, 10 &#125;; Using an array (P19) Once we create an array, its size is fixed. A program can refer to the length of an array a[] with the code a.length. Aliasing (P19) … an array name refers to the whole array–if we assign one array name to another, then both refer to the sanme array… Two-dimensional arrays (P19) an M-by-N array 1double[][] a = new double[M][N]; 12345double[][] a;a = new double[M][N];for(int i = 0; i &lt; M; i++) for(int j = 0; j &lt; N; j++) a[i][j] = 0.0; Invoking a static method (P22) A return statement terminates a static method, returning control to the caller. Typical implementations of static methods (P23) primality test（判断是否为素数） 素数是指除了1和它本身之外，不能被任何整数整除的数。 首先，如果一个数不是素数，那么它能写成两个因子乘积的形式，例如N=a∗bN = a * bN=a∗b，此时，aaa与bbb中肯定一个小于N\\sqrt{N}N​，另一个大于等于N\\sqrt{N}N​，因此只需判断NNN是否能被222~N\\sqrt{N}N​之间的是整除即可。 如果NNN不能被222~N\\sqrt{N}N​之间的数整除，则NNN为素数。 1234567public static boolean isPrime(int N)&#123; if(N &lt; 2) return false; for(int i = 2; i*i &lt;= N; i++) if(N % i == 0) return false; return true;&#125; square root(Newton’s method) 这里求解算术平方根用到的是牛顿迭代法。 先说一般的牛顿迭代法，现要求解非线性方程f(x)=0f(x)=0f(x)=0的根。将f(x)f(x)f(x)在xnx_nxn​处展开得： f(x)=f(xn)+f′(xn)(x−xn)+O((x−xn)2) f(x)=f(x_n)+f&#x27;(x_n)(x-x_n)+O({(x-x_n)}^2) f(x)=f(xn​)+f′(xn​)(x−xn​)+O((x−xn​)2) 截取线性部分，加之f(x)=0f(x)=0f(x)=0，移项可得x=xn−f(xn)f′(xn)x=x_n- \\frac{f(x_n)}{f&#x27;(x_n)}x=xn​−f′(xn​)f(xn​)​，因此下一个点可为xn+1=xn−f(xn)f′(xn)x_{n+1}=x_n- \\frac{f(x_n)}{f&#x27;(x_n)}xn+1​=xn​−f′(xn​)f(xn​)​。 在求解算术平方根中，f(c)=c2f(c)=c^2f(c)=c2，可得cn+1=cn−cn22cnc_{n+1}=c_n-\\frac{ {c_n}^2}{2c_n}cn+1​=cn​−2cn​cn​2​。？？？ 123456789public static double sqrt(double c)&#123; if(c &lt; 0) return Double.NaN; double err = 1e-15; double t = c; while (Math.abs(t - c/t) &gt; err * t) t = (c/t + t) / 2.0; return t;&#125; Recursion (P25) 在递归程序中三个重要的规则: The recursion has a base case–we always include a conditional statement as the first statement in the program that has a return. Recursive calls must address subproblems that are smaller in some sense, so that recursive calls converge to the base case. Recursive calls should not address subproblems that overlap. Input and output (P36) Words 单词 释义 P3 amenable adj.合适的 hypothese 假设 connectivity 连通性 P4 devise 设计 go hand in hand 手拉手地前进；紧密联系；息息相关 P5 reap vt. &amp; vi. 收割庄稼; 收获 occasion n. 场合；时机，机会；理由 vt. 引起，惹起 fraction n. 小部分；部分；稍微；[数]分数 tune n. 曲调, 曲子 vt. &amp; vi. 调音 vt. 调整 P6 comparative adj. 比较的, 相比的,相比之下的, 相比而言的, 相对的 indication n. 指示, 表示 P7 suffix array 后缀阵列 underpinning n. 基础,支柱,支撑 intricate adj. 错综复杂的 P8 concise adj. 简明的 downside adj. 下降趋势的 depict vt. 描绘; 描画 defer vt. 拖延, 延缓, 推迟vi. 服从某人的意愿, 遵从 annotation n. 注解,注释 idiom n. 成语，习语；土话 P9 anatomy n. 解剖, 解剖学,分析 encapsulate vt. 装入胶囊总结;扼要概括;囊括adj. 有(胶)囊包着的 P11 alphanumeric adj. 文字数字的,包括文字与数字的 manipulate vt. 熟练控制[操作] permissible adj. 可允许的, 许可的 primitive adj. 原始的, 早期的 literal adj. 逐字的；无夸张的；文字的 P13 infix vt. 使…钻进,让…插进n. 插入词,中缀 precedence n. 领先于…的权利;优先权 parentheses n. 圆括号,插入语,插曲 type conversion 类型转换 promote vt. 提升, 提拔〈正〉促进; 推动; 增进 cast vt. &amp; vi. 投, 掷, 扔,浇铸vt. 投射, 加…于分配(演戏剧等的)角色 intricate adj. 错综复杂的 sparingly adv. 节俭地;爱惜地;保守地;谨慎地 persist vi. 持续，固执；存留，坚持 P14 manipulate vt. 熟练控制[操作] curly brace 花括号 associate vt. &amp; vi. (使)发生联系, (使)联合; 结交, 结伙adj. 副的；联合的 a nested structure 嵌套结构 scope n. 视野；眼界；范围；余地；导弹射程 P15 template n. 模板 refrain vi. 制止；避免；节制，克制 self-explanatory adj. 不解自明的;明显的 P16 prepend vt. 预先考虑；预谋 operand n. [计]操作数；[数]运算对象 compactly adv. 细密地,简洁地 P18 unambiguously adv. 明白地,不含糊地 P19 comma n. 逗号；停顿 aliasing n. 别名使用；[数]混淆现象 ragged adj.参差不齐的, 凹凸不平的 superfluous adj. 过多的; 过剩的; 多余的 P22 encapsulate vt. 总结;扼要概括;囊括 side effect n. 副作用 semicolon n. 分号 terminate vt. &amp; vi. 结束; 使终结 P24 indicate vt. 标示, 指示, 指出 P25 succinct adj. 简洁的；简明的；紧身的 overlap n. 重叠；重复vi. 部分重叠；部分的同时发生 P27 scant adj. 不足的；缺乏的；勉强够的vt. 减少；节省；限制 P29 excerpt n. 摘录, 摘要vt. 选录, 摘录 delineate vt. 勾画,描述 P31 bedrock n. 根底；基岩；基本原理 overstate vt. 夸大(某事) articulate adj. 表达能力强的;口齿清楚的, 发音清晰的vt. &amp; vi. 清楚地表达 P33 substitute vt. &amp; vi. 代替, 替换, 代用 P34 concatenation n. 一系列互相关联的事物 conversion n. 变换, 转化 P35 paradigm n. 范例；词形变化表 P36 generic adj. 一般的；属的；类的；非商标的 书籍信息 《算法》","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://example.com/tags/Algorithms/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"欧拉方法、隐式欧拉方法","date":"2021-03-11T07:11:09.000Z","path":"2021/03/11/微分方程数值解/欧拉方法、隐式欧拉方法/","text":"求解如下常微分方程： {dudt=−ut,1≤t≤2u(1)=1\\begin{aligned} \\begin{cases} \\frac{du}{dt}=-\\frac{u}{t},1\\leq t\\leq 2\\\\ u(1)=1 \\end{cases} \\end{aligned} {dtdu​=−tu​,1≤t≤2u(1)=1​​ 精确解 将原方程化为tdu+udt=0tdu+udt=0tdu+udt=0，则有d(ut)=0d(ut)=0d(ut)=0，解得ut=Cut=Cut=C(CCC为常数)，代入初始条件得C=1C=1C=1，从而该方程的精确解为： u=1t,(1≤t≤2).\\begin{aligned} u=\\frac{1}{t},(1\\leq t \\leq2). \\end{aligned} u=t1​,(1≤t≤2).​ 欧拉方法 代入欧拉格式得： ui+1=ui+hf(ti,ui)=ui+h(−uiti)\\begin{aligned} u_{i+1}=u_{i}+hf(t_i,u_i)=u_i+h(-\\frac{u_i}{t_i}) \\end{aligned} ui+1​=ui​+hf(ti​,ui​)=ui​+h(−ti​ui​​)​ 隐式欧拉方法 由隐式欧拉格式得： ui+1=ui+hf(ti+1,ui+1)=ui+h(−ui+1ti+1)，\\begin{aligned} u_{i+1}=u_{i}+hf(t_{i+1},u_{i+1})=u_i+h(-\\frac{u_{i+1}}{t_{i+1}})， \\end{aligned} ui+1​=ui​+hf(ti+1​,ui+1​)=ui​+h(−ti+1​ui+1​​)，​ 移项化简可得： ui+1=ti+1uiti+1+h\\begin{aligned} u_{i+1}=\\frac{t_{i+1}u_i}{t_{i+1}+h} \\end{aligned} ui+1​=ti+1​+hti+1​ui​​​ 程序 根据上述推导，用python编写程序，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# implict euler methodimport numpy as npimport matplotlib.pyplot as plt# the right term of the ODEdef f(t, u): f = -u/t return f# the exact solution of ODE def fexact(t): fexact = 1/t return fexactN = 100t_n = 2.0dt = (t_n - 1.0) / Nt = np.arange(1.0, t_n + dt, dt)u_euler = np.arange(1.0, t_n + dt, dt)u = np.arange(1.0, t_n + dt, dt)u_true = np.arange(1.0, t_n + dt, dt)i = 0while i &lt; N: t[i+1] = t[i] + dt u_euler[i+1] = u_euler[i] + dt * f(t[i], u_euler[i]) u[i+1] = (u[i] * t[i+1])/(t[i+1] + dt) u_true[i+1] = fexact(t[i+1]) i = i + 1err_euler = max(abs(u_euler - u_true))err_implict_euler = max(abs(u - u_true))print(&quot;The error of euler method: &quot;,err_euler)print(&quot;The error of implict euler method: &quot;,err_implict_euler)# begin drawingplt.title(&#x27;Result&#x27;)plt.plot(t, u_euler, color=&#x27;green&#x27;, label=&#x27;euler&#x27;)plt.plot(t, u, color=&#x27;blue&#x27;, label=&#x27;implict euler&#x27;)plt.plot(t, u_true, color=&#x27;red&#x27;, label=&#x27;exact&#x27;)plt.legend() # show the legendplt.xlabel(&#x27;t&#x27;)plt.ylabel(&#x27;u&#x27;)plt.show() 结果分析 当取h=0.01h=0.01h=0.01时，此时欧拉方法的误差为0.02631578947368396，隐式欧拉方法的误差为0.023809523809523836，结果如下图所示： 当取不同hhh，得到的误差如下表所示： hhh 欧拉方法 隐式欧拉方法 12\\frac{1}{2}21​ 0.16666666666666663 0.09999999999999998 14\\frac{1}{4}41​ 0.0714285714285714 0.05555555555555558 18\\frac{1}{8}81​ 0.033333333333333215 0.02941176470588236 116\\frac{1}{16}161​ 0.01612903225806467 0.015151515151515138 132\\frac{1}{32}321​ 0.00793650793650813 0.007692307692307665 164\\frac{1}{64}641​ 0.0039370078740155193 0.003875968992248069","tags":[{"name":"欧拉方法","slug":"欧拉方法","permalink":"http://example.com/tags/%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95/"},{"name":"隐式欧拉方法","slug":"隐式欧拉方法","permalink":"http://example.com/tags/%E9%9A%90%E5%BC%8F%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95/"},{"name":"数值分析","slug":"数值分析","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"},{"name":"微分方程数值解","slug":"微分方程数值解","permalink":"http://example.com/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%95%B0%E5%80%BC%E8%A7%A3/"}]}]