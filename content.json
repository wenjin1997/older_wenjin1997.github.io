[{"title":"461.汉明距离","date":"2021-05-27T09:01:00.000Z","path":"2021/05/27/LeetCode/461.汉明距离/","text":"官方链接 题目 题目描述 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数x和y，计算它们之间的汉明距离。 注意： 0≤x,y&lt;231.0 ≤ x, y &lt; 2^{31}.0≤x,y&lt;231. 示例: 123456输入: x &#x3D; 1, y &#x3D; 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑ 上面的箭头指出了对应二进制位不同的位置。 题解思路 对于异或运算，相同为0，不同为1.先计算z=x⊕yz=x \\oplus yz=x⊕y，接着计算zzz中1的个数。 首先让zzz与1进行与运算，如果结果为1，则说明低位是1，计数器加一。接着将zzz右移，高位补充为0，继续判断低位是不是1，直到zzz最后为0，结束这个过程。 Java代码： 1234567891011121314class Solution &#123; public int hammingDistance(int x, int y) &#123; int z = x ^ y; int ans = 0; // 计算x^y后得到的z的二进制位中有多少个1 while (z &gt; 0) &#123; if ((z &amp; 1) == 1) &#123; ans ++; &#125; z &gt;&gt;= 1; // 右移 &#125; return ans; &#125;&#125; 补充资料 Java中的移位运算 算法-求二进制中1的个数","tags":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"1277.统计全为1的正方形子矩阵","date":"2021-05-25T03:35:00.000Z","path":"2021/05/25/LeetCode/1277.统计全为1的正方形子矩阵/","text":"官方链接 题目 官方题解 题目描述 给你一个m * n的矩阵，矩阵中的元素不是0就是1，请你统计并返回其中完全由1组成的正方形子矩阵的个数。 示例 1： 123456789101112输入：matrix &#x3D;[ [0,1,1,1], [1,1,1,1], [0,1,1,1]]输出：15解释： 边长为 1 的正方形有 10 个。边长为 2 的正方形有 4 个。边长为 3 的正方形有 1 个。正方形的总数 &#x3D; 10 + 4 + 1 &#x3D; 15. 示例 2： 1234567891011输入：matrix &#x3D; [ [1,0,1], [1,1,0], [1,1,0]]输出：7解释：边长为 1 的正方形有 6 个。 边长为 2 的正方形有 1 个。正方形的总数 &#x3D; 6 + 1 &#x3D; 7. 提示： 1 &lt;= arr.length &lt;= 300 1 &lt;= arr[0].length &lt;= 300 0 &lt;= arr[i][j] &lt;= 1 动态规划 用dp[i][j]代表以(i,j)元为右下角的所有正方形中全为1的正方形个数之和。递推式参考官方题解。 Java代码： 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int countSquares(int[][] matrix) &#123; int m = matrix.length; int n = matrix[0].length; int[][] dp = new int[m][n]; int ans = 0; for (int i = 0; i &lt; m; i++) &#123; dp[i][0] = matrix[i][0]; ans += dp[i][0]; // System.out.printf(&quot;ans[%d,0]=%d\\n&quot;,i,dp[i][0]); &#125; for (int j = 1; j &lt; n; j++) &#123; dp[0][j] = matrix[0][j]; ans += dp[0][j]; // System.out.printf(&quot;ans[0,%d]=%d\\n&quot;,j,dp[0][j]); &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (matrix[i][j] != 0) &#123; dp[i][j] = Math.min(dp[i-1][j], Math.min(dp[i-1][j-1], dp[i][j-1])) + 1; ans += dp[i][j]; // System.out.printf(&quot;ans[%d,%d]=%d\\n&quot;,i,j,dp[i][j]); &#125; &#125; &#125; return ans; &#125;&#125;","tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode中等","slug":"LeetCode中等","permalink":"http://example.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"数值求解热传导方程","date":"2021-05-24T05:59:00.000Z","path":"2021/05/24/微分方程数值解/数值求解热传导方程/数值求解热传导方程/","text":"最简显格式 对于如下热传导方程： {∂u∂t=∂2u∂t0&lt;t&lt;0.03,0&lt;x&lt;1u(x,0)=sin⁡(4πx)0≤x≤1u(0,t)=00≤t≤0.03u(1,t)=00≤t≤0.03 \\begin{cases} \\frac{\\partial u}{\\partial t} =\\frac{\\partial ^2 u}{\\partial t} \\quad 0&lt;t&lt;0.03,0&lt;x&lt;1 \\\\ u(x,0)=\\sin(4\\pi x) \\quad 0 \\le x \\le 1 \\\\ u(0,t) = 0 \\quad 0 \\le t \\le 0.03 \\\\ u(1,t) = 0 \\quad 0 \\le t \\le 0.03 \\end{cases} ⎩⎪⎪⎪⎨⎪⎪⎪⎧​∂t∂u​=∂t∂2u​0&lt;t&lt;0.03,0&lt;x&lt;1u(x,0)=sin(4πx)0≤x≤1u(0,t)=00≤t≤0.03u(1,t)=00≤t≤0.03​ 该方程的精确解为u(t,x)=e−(4π)2tsin⁡(4πx),0≤t≤0.03,0≤x≤1.u(t,x)=e^{-(4\\pi)^2t}\\sin (4 \\pi x),0\\le t \\le 0.03, 0 \\le x \\le 1.u(t,x)=e−(4π)2tsin(4πx),0≤t≤0.03,0≤x≤1. 首先对时间及空间进行划分，将时间划分为m−1m-1m−1份，将空间划分为n−1n-1n−1份，则τ=0.03m−1,h=1n−1\\tau=\\frac{0.03}{m-1},h=\\frac{1}{n-1}τ=m−10.03​,h=n−11​。 根据最简显格式可以得到： uji+1=τh2(uj+1i−2uji+uj−1i)+uji, u_j^{i+1}=\\frac{\\tau}{h^2}(u_{j+1}^{i}-2u_j^i+u_{j-1}^i)+u_j^{i}, uji+1​=h2τ​(uj+1i​−2uji​+uj−1i​)+uji​, 其中i=0,1,⋯ ,m−1i=0,1,\\cdots,m-1i=0,1,⋯,m−1，j=0,1,⋯ ,n−1j=0,1,\\cdots,n-1j=0,1,⋯,n−1。 编程实现 根据理论推导，用python编写程序如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# -*- coding: utf-8 -*-&quot;&quot;&quot;Created on Sun May 23 11:16:13 2021@author: XieWenjin&quot;&quot;&quot;import mathimport numpy as npfrom matplotlib import pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dt = 0.03 # 时间范围x = 1.0 # 空间范围m = input(&quot;请输入m：&quot;)m = int(m)n = input(&quot;请输入n：&quot;)n = int(n)# m = 320 # 时间方向分为320个格子# n = 64 # 空间方向的格子数dt = t / (m - 1) # 时间步长dx = x / (n - 1) # 空间步长 def generate_u(m,n): u = np.zeros([m,n]) # 边界条件 for j in range(n): u[0,j] = math.sin(4 * math.pi * j * dx) for i in range(m): u[i,0] = 0 u[i,-1] = 0 # 差分法 for i in range(m - 1): for j in range(1,n - 1): u[i+1, j] = dt * (u[i, j + 1] + u[i, j - 1] - 2 * u[i, j]) / dx ** 2 + u[i, j] return udef drawing(X,Y,Z): fig = plt.figure() ax = Axes3D(fig) ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=&#x27;rainbow&#x27;) plt.show()def error(u,u_exact): err = abs(u - u_exact) return max(map(max, err))X = np.arange(0, t + dt, dt) # remark:t+dt,not tY = np.arange(0, x + dx, dx)X, Y = np.meshgrid(X, Y)u_exact = np.exp(- (4*np.pi)**2*X)*np.sin(4*np.pi*Y)u = generate_u(m,n)u = np.transpose(u) # 注意这里是转置，而不是np.reshape(u,(n,m))# print(m,n)print(error(u,u_exact))drawing(X,Y,u) # 数值解# drawing(X,Y,u_exact) # 精确解# drawing(X,Y,abs(u-u_exact)) # 数值解与精确解之差的绝对值 结果分析 当取m=320,n=64m=320,n=64m=320,n=64时，得到数值解[u][u][u]如下图所示： 数值解$[u]$ 精确解uuu如下图所示： 精确解$u$ 精确解与数值解之差的绝对值∣∣u−[u]∣∣||u-[u]||∣∣u−[u]∣∣如下图所示： 精确解与数值解之差的绝对值$||u-[u]||$ 当取不同的τ,h\\tau,hτ,h时，计算得到的误差如下表所示。 τ\\tauτ hhh 误差eee ei/ei+1e_i/e_{i+1}ei​/ei+1​ 110\\frac{1}{10}101​ 110\\frac{1}{10}101​ 0.0428079643162558 140\\frac{1}{40}401​ 120\\frac{1}{20}201​ 0.00951825176096948 4.4975 1160\\frac{1}{160}1601​ 140\\frac{1}{40}401​ 0.00244056613219328 3.9000 1640\\frac{1}{640}6401​ 180\\frac{1}{80}801​ 0.000606385251482932 4.0248 12560\\frac{1}{2560}25601​ 1160\\frac{1}{160}1601​ 0.000151362159712509 4.0062 我们知道最简显格式的误差为∣∣[u]k−uk∣∣=O(τ+h2)||[u]^k-u^k||=O(\\tau + h^2)∣∣[u]k−uk∣∣=O(τ+h2)，设ei=C×(τi+hi2)e_i=C \\times (\\tau_i + h_i^2)ei​=C×(τi​+hi2​)， 取τi+1=14τi\\tau_{i+1}=\\frac{1}{4} \\tau_iτi+1​=41​τi​,hi+1=12hih_{i+1}=\\frac{1}{2}h_ihi+1​=21​hi​，可以得到eiei+1=4\\frac{e_i}{e_{i+1}} =4ei+1​ei​​=4，与上表结果相符，从而也验证了最简显格式的误差阶数为O(τ+h2)O(\\tau + h^2)O(τ+h2).","tags":[{"name":"热传导方程","slug":"热传导方程","permalink":"http://example.com/tags/%E7%83%AD%E4%BC%A0%E5%AF%BC%E6%96%B9%E7%A8%8B/"},{"name":"最简显格式","slug":"最简显格式","permalink":"http://example.com/tags/%E6%9C%80%E7%AE%80%E6%98%BE%E6%A0%BC%E5%BC%8F/"},{"name":"数值分析","slug":"数值分析","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"},{"name":"微分方程数值解","slug":"微分方程数值解","permalink":"http://example.com/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%95%B0%E5%80%BC%E8%A7%A3/"}]},{"title":"121.买卖股票的最佳时机","date":"2021-05-24T05:24:00.000Z","path":"2021/05/24/LeetCode/121.买卖股票的最佳时机/","text":"官方链接 题目 官方解答 题目描述 给定一个数组prices，它的第i个元素prices[i]表示一支给定股票第i天的价格。 你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回0。 示例 1： 1234输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 123输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 10510^5105 0 &lt;= prices[i] &lt;= 10410^4104 题解思路 最初的解答这道题的想法是找到数组中下标最小的最小值，再用每一天的价格减去这个最小值，最终得到的最大数是最大利润，在测试用例时，这种思路是不对的，如数组[2,4,1,1,1]，最小值为1，但算出来的利润其实为0，实际最大利润应为2。 上述思路出错的原因是：不应该考虑整个数组的最小值，而应该考虑历史最小值。假设是自己在买股票，那么当天可以决定是否卖出股票，应该在历史最低处买入，再决定当天是否卖出股票。 Java代码如下： 123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; int min = prices[0]; int maxprofit = 0; for (int i = 0; i &lt; prices.length; i++) &#123; if (prices[i] &lt; min) &#123; min = prices[i]; &#125; else if (prices[i] - min &gt; maxprofit) &#123; maxprofit = prices[i] - min; &#125; &#125; return maxprofit; &#125;&#125; 时间复杂度为O(n)O(n)O(n)，空间复杂度为O(1)O(1)O(1)。 Remark 可以将最小值初始化为prices[0]，也可以初始化为Integer.MAX_VALUE。 Java中数组按升序排列：Arrays.sort(dp);","tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"22.括号生成","date":"2021-05-23T01:41:09.000Z","path":"2021/05/23/LeetCode/22.括号生成/","text":"官方链接 题目 官方解答 题目描述 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 12输入：n &#x3D; 3输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;] 示例 2： 12输入：n &#x3D; 1输出：[&quot;()&quot;] 提示： 1 &lt;= n &lt;= 8 回溯法 参考官方解答。 123456789101112131415161718192021222324class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; ans = new ArrayList&lt;String&gt;(); backtrack(ans, new StringBuilder(), 0, 0, n); return ans; &#125; public void backtrack(List&lt;String&gt; ans, StringBuilder cur, int open, int close, int max) &#123; if (cur.length() == max * 2) &#123; ans.add(cur.toString()); return; &#125; if (open &lt; max) &#123; cur.append(&#x27;(&#x27;); backtrack(ans, cur, open + 1, close, max); cur.deleteCharAt(cur.length() - 1); &#125; if (close &lt; open) &#123; cur.append(&#x27;)&#x27;); backtrack(ans, cur, open, close + 1, max); cur.deleteCharAt(cur.length() - 1); &#125; &#125;&#125;","tags":[{"name":"LeetCode中等","slug":"LeetCode中等","permalink":"http://example.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"回溯算法","slug":"回溯算法","permalink":"http://example.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"}]},{"title":"368. 最大整除子集","date":"2021-05-22T13:53:09.000Z","path":"2021/05/22/LeetCode/368. 最大整除子集/","text":"题目描述 最大整除子集 给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足： answer[i] % answer[j] == 0 ，或 answer[j] % answer[i] == 0 如果存在多个有效解子集，返回其中任何一个均可。 示例 1： 123输入：nums &#x3D; [1,2,3]输出：[1,2]解释：[1,3] 也会被视为正确答案。 示例 2： 12输入：nums &#x3D; [1,2,4,8]输出：[1,2,4,8] 提示： 1 &lt;= nums.length &lt;= 1000 1 &lt;= nums[i] &lt;= 2 * 109 nums 中的所有整数 互不相同 题解 参看了官方解答，动态规划的思想来求解这道题。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package leetcode;import java.util.Scanner;import java.util.List;import java.util.ArrayList;import java.util.Arrays;public class LargestDivisibleSubset &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int[] nums = new int[n]; for(int l = 0; l &lt; n; l++) &#123; nums[l] = in.nextInt(); &#125; Arrays.sort(nums); int[] dp = new int[n]; Arrays.fill(dp, 1); dp[0] = 1; int maxVal = nums[0], maxSize = 1; // 第一步 动态规划找到最大子集的个数，最大子集中的最大整数 for(int i = 1; i &lt; n; i++) &#123; for(int j = 0; j &lt; i; j++) &#123; if(nums[i] % nums[j] == 0) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; if(dp[i] &gt; maxSize) &#123; maxSize = dp[i]; maxVal = nums[i]; &#125; &#125; //第二步 倒推得到最大子集 List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(maxSize == 1) &#123; res.add(nums[0]); System.out.println(res); &#125; for(int i = n - 1; i &gt;= 0 &amp;&amp; maxSize &gt; 0; i--) &#123; if(maxVal % nums[i] == 0 &amp;&amp; dp[i] == maxSize) &#123; res.add(nums[i]); maxVal = nums[i]; maxSize--; &#125; &#125; System.out.println(res);&#125;","tags":[{"name":"LeetCode中等","slug":"LeetCode中等","permalink":"http://example.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"1035.不相交的线","date":"2021-05-21T09:04:09.000Z","path":"2021/05/21/LeetCode/1035.不相交的线/","text":"官方链接 题目 官方解答 题目描述 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。 现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足： nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。 以这种方法绘制线条，并返回可以绘制的最大连线数。 示例 1： 1234输入：nums1 &#x3D; [1,4,2], nums2 &#x3D; [1,2,4]输出：2解释：可以画出两条不交叉的线，如上图所示。 但无法画出第三条不相交的直线，因为从 nums1[1]&#x3D;4 到 nums2[2]&#x3D;4 的直线将与从 nums1[2]&#x3D;2 到 nums2[1]&#x3D;2 的直线相交。 示例 2： 12输入：nums1 &#x3D; [2,5,1,2,5], nums2 &#x3D; [10,5,2,1,5,2]输出：3 示例 3： 12输入：nums1 &#x3D; [1,3,7,1,7,5], nums2 &#x3D; [1,9,2,5,1]输出：2 提示： 1231 &lt;&#x3D; nums1.length &lt;&#x3D; 5001 &lt;&#x3D; nums2.length &lt;&#x3D; 5001 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 2000 题解思路 参考官方解答，用动态规划方法，重点是推导出动态转移方程。 代码 123456789101112131415161718class Solution &#123; public int maxUncrossedLines(int[] nums1, int[] nums2) &#123; int n = nums1.length; int m = nums2.length; int[][] dp = new int[n + 1][m + 1]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[n][m]; &#125;&#125;","tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode中等","slug":"LeetCode中等","permalink":"http://example.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"}]},{"title":"91.解码方法","date":"2021-05-20T11:17:09.000Z","path":"2021/05/20/LeetCode/91.解码方法/","text":"题目描述 解码方法 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ： ‘A’ -&gt; 1 ‘B’ -&gt; 2 … ‘Z’ -&gt; 26 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，“11106” 可以映射为： “AAJF” ，将消息分组为 (1 1 10 6) “KJF” ，将消息分组为 (11 10 6) 注意，消息不能分组为 (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。 题目数据保证答案肯定是一个 32 位 的整数。 示例 1： 123输入：s &#x3D; &quot;12&quot;输出：2解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。 示例 2： 123输入：s &#x3D; &quot;226&quot;输出：3解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。 示例 3： 12345输入：s &#x3D; &quot;0&quot;输出：0解释：没有字符映射到以 0 开头的数字。含有 0 的有效映射是 &#39;J&#39; -&gt; &quot;10&quot; 和 &#39;T&#39;-&gt; &quot;20&quot; 。由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。 示例 4： 123输入：s &#x3D; &quot;06&quot;输出：0解释：&quot;06&quot; 不能映射到 &quot;F&quot; ，因为字符串含有前导 0（&quot;6&quot; 和 &quot;06&quot; 在映射中并不等价）。 提示： 1 &lt;= s.length &lt;= 100 s 只包含数字，并且可能包含前导零。 题解思路 参考了官方解答，方法是动态规划。 设字符串sss的长度为nnn，从左到右的字符依次为s[1],s[2],⋯ ,s[n]s[1],s[2],\\cdots,s[n]s[1],s[2],⋯,s[n]。 设fif_ifi​表示字符串sss前iii个字符的解码方法数，则有两种情况： （1）只有一个字符，该字符不能为0，则一定可以解码，可以进行状态转移，此时 fi=fi−1,其中si−1≠0f_i = f_{i-1}, \\quad 其中s_{i-1} \\ne 0 fi​=fi−1​,其中si−1​​=0 (2)有两个字符，第一个字符同样不能为0，同时两个字符组成的十进制数要小于等于26，也就是 fi=fi−2,其中si−2≠0,si−2×10+si−1≤26f_i = f_{i-2}, \\quad 其中s_{i-2} \\ne 0, s_{i-2}\\times10+s_{i-1}\\le26 fi​=fi−2​,其中si−2​​=0,si−2​×10+si−1​≤26 为了不超出指标，这里i&gt;1i&gt;1i&gt;1。 这里的边界条件为： f0=1f_0=1 f0​=1 空字符串可以有一种解码方式，也就是解码出一个空字符串。 代码实现 1234567891011121314151617181920212223242526package leetcode;import java.util.Scanner;public class DecodeWays &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String s = in.nextLine(); int n = s.length(); int[] f = new int[n+1]; f[0] = 1; for(int i = 1; i &lt;= n; i++) &#123; if(s.charAt(i - 1) != &#x27;0&#x27;) &#123; f[i] += f[i - 1]; &#125; if( i &gt; 1 &amp;&amp; (s.charAt(i - 2) != &#x27;0&#x27;) &amp;&amp; (((s.charAt(i - 1) - &#x27;0&#x27;) * 10 + (s.charAt(i - 2) - &#x27;0&#x27;)) &lt;= 26)) &#123; f[i] += f[i - 2]; &#125; &#125; System.out.println(f[n]); &#125;&#125;","tags":[{"name":"LeetCode中等","slug":"LeetCode中等","permalink":"http://example.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"69.x的平方根","date":"2021-05-19T13:40:09.000Z","path":"2021/05/19/LeetCode/69.x的平方根/","text":"题目描述 x的平方根 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 12输入: 4 输出: 2 示例 2: 12输入: 8 输出: 2 说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 牛顿迭代法 推导牛顿迭代法的公式，现在要求数CCC的算术平方根，设求解得到算术平方根为xxx，则x2=Cx^2=Cx2=C，从而代入牛顿迭代法的式子有： f(x)=x2−C f(x)=x^2-C f(x)=x2−C 对f(x)f(x)f(x)求导得： f′(x)=2x f&#x27;(x)=2x f′(x)=2x 从而迭代公式为： xn+1=xn−f(xn)f′(xn)=xn−xn2−C2xn=xn2−C2xn=xn2−C2xn x_{n+1}=x_n-\\frac{f(x_n)}{f&#x27;(x_n)}=x_n-\\frac{x_n^2-C}{2x_n}=\\frac{x_n^2-C}{2x_n}=\\frac{x_n}{2}-\\frac{C}{2x_n} xn+1​=xn​−f′(xn​)f(xn​)​=xn​−2xn​xn2​−C​=2xn​xn2​−C​=2xn​​−2xn​C​ Java代码实现如下： 123456789101112131415161718192021222324package leetcode;import java.util.Scanner;// 牛顿迭代法public class Sqrtx &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int c = in.nextInt(); double err = 2; double xn = c; double xn_1; while(err &gt; 0.01) &#123; xn_1 = xn / 2.0 + c / (2 * xn); System.out.println(&quot;xn_1:&quot; + xn_1); err = Math.abs(xn_1 - xn); System.out.println(&quot;err: &quot; + err); xn = xn_1; &#125; System.out.println((int)xn); &#125;&#125; 这里迭代终止条件是∣∣xn+1−xn∣∣1&lt;error||x_{n+1}-x_n||_1&lt;error∣∣xn+1​−xn​∣∣1​&lt;error。","tags":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"},{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"1442.形成两个异或相等数组的三元数组","date":"2021-05-18T12:12:09.000Z","path":"2021/05/18/LeetCode/1442.形成两个异或相等数组的三元数组/","text":"官方链接 题目 官方解答 题目描述 给你一个整数数组 arr 。 现需要从数组中取三个下标 i、j 和 k ，其中 (0 &lt;= i &lt; j &lt;= k &lt; arr.length) 。 a 和 b 定义如下： a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1] b = arr[j] ^ arr[j + 1] ^ … ^ arr[k] 注意：^ 表示 按位异或 操作。 请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。 示例 1： 123输入：arr &#x3D; [2,3,1,6,7]输出：4解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4) 示例 2： 12输入：arr &#x3D; [1,1,1,1,1]输出：10 示例 3： 12输入：arr &#x3D; [2,3]输出：0 示例 4： 12输入：arr &#x3D; [1,3,5,7,9]输出：3 示例 5： 12输入：arr &#x3D; [7,11,12,9,5,2,7,17,22]输出：8 提示： 1 &lt;= arr.length &lt;= 300 1 &lt;= arr[i] &lt;= 10810^8108 题解思路 设SiS_iSi​表示前arr数组前iii项异或的结果，即 S0=0Si=arr0⊕arr1⊕arr2⊕⋯⊕arri−1,1≤i≤nS_0= 0 \\\\ S_i = arr_0 \\oplus arr_1 \\oplus arr_2 \\oplus \\cdots \\oplus arr_{i-1}, \\quad 1\\le i \\le n S0​=0Si​=arr0​⊕arr1​⊕arr2​⊕⋯⊕arri−1​,1≤i≤n 则 Si=Si−1⊕arri−1,1≤i≤n.S_i = S_{i-1} \\oplus arr_{i-1}, \\quad 1\\le i \\le n. Si​=Si−1​⊕arri−1​,1≤i≤n. 因此 a=arri⊕arri+1⊕⋯⊕arrj−1=Si⊕Sja=arr_i \\oplus arr_{i+1} \\oplus \\cdots \\oplus arr_{j-1} \\\\ =S_{i} \\oplus S_j a=arri​⊕arri+1​⊕⋯⊕arrj−1​=Si​⊕Sj​ b=arrj⊕⋯⊕arrk=Sj⊕Sk+1b= arr_j \\oplus \\cdots \\oplus arr_k \\\\ = S_j \\oplus S_{k+1} b=arrj​⊕⋯⊕arrk​=Sj​⊕Sk+1​ 从而由a=ba=ba=b，得到 Si⊕Sj=Sj⊕Sk+1S_i \\oplus S_j = S_j \\oplus S_{k+1} \\\\ Si​⊕Sj​=Sj​⊕Sk+1​ 即 Si=Sk+1S_i = S_{k+1} Si​=Sk+1​ 三重循环 12345678910111213141516171819class Solution &#123; public int countTriplets(int[] arr) &#123; int n = arr.length; int[] s = new int[n + 1]; // 前i项异或结果 for (int i = 1; i &lt;= n; i++) &#123; s[i] = s[i-1] ^ arr[i-1]; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; for (int k = j; k &lt; n; k++) &#123; if (s[i] == s[k + 1]) ans++; &#125; &#125; &#125; return ans; &#125;&#125; 两重循环 1234567891011121314151617class Solution &#123; public int countTriplets(int[] arr) &#123; int n = arr.length; int[] s = new int[n + 1]; // 前i项异或结果 for (int i = 1; i &lt;= n; i++) &#123; s[i] = s[i-1] ^ arr[i-1]; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int k = i + 1; k &lt; n; k++) &#123; if (s[i] == s[k + 1]) ans += k - i; &#125; &#125; return ans; &#125;&#125;","tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode中等","slug":"LeetCode中等","permalink":"http://example.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"67.二进制求和","date":"2021-05-18T03:25:00.000Z","path":"2021/05/18/LeetCode/67.二进制求和/","text":"官方链接 二进制求和 官方解答 题目描述 给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 12输入: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;输出: &quot;100&quot; 示例 2: 12输入: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot; 输出: &quot;10101&quot; 提示： 每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。 1 &lt;= a.length, b.length &lt;= 10410^4104 字符串如果不是 “0” ，就都不含前导零。 字符串转换为数值 8个包装类都提供了一个parseXxx(String str)静态方法用于将字符串转换成基本类型。 1234567891011String s = &quot;123&quot;;byte b = Byte.parseByte(s);short t = Short.parseShort(s);int i = Integer.parseInt(s);long l = Long.parseLong(s);Float f = Float.parseFloat(s);Double d = Double.parseDouble(s);boolean bo = Boolean.parseBoolean(s);System.out.println(&quot;b &quot; + b + &quot; t &quot;+ t +&quot; i: &quot;+ i + &quot; l: &quot;+ l); 题解思路 123456789101112131415161718192021222324252627package leetcode;public class AddBinary &#123; public static void main(String[] args) &#123; String a = &quot;1101&quot;; String b = &quot;11&quot;; StringBuilder ans = new StringBuilder(); int n = Math.max(a.length(), b.length()), carry = 0; for(int i = 0; i &lt; n; ++i) &#123; carry += i &lt; a.length() ? (a.charAt(a.length() - 1 - i) - &#x27;0&#x27;) : 0; carry += i &lt; b.length() ? (b.charAt(b.length() - 1 - i) - &#x27;0&#x27;) : 0; ans.append((char)(carry % 2 + &#x27;0&#x27;)); carry = carry / 2; &#125; if(carry &gt; 0) &#123; ans.append(&#x27;1&#x27;); &#125; ans.reverse(); System.out.println(ans.toString()); &#125;&#125; 思路是按照位运算，逢2进1。在代码中carry表示的是位于位运算后得到的数，carry与2取余后得到结果中该位的数，如果有进位，保留到下一位的计算中。 这里StringBuilder也可以改为StringBuffer，StringBuilder类在Java5中引入。这个类的前生就是StringBuffer，它的效率稍有些低，但允许采用多线程的方式添加或删除字符。如果所有字符串编辑操作都在单个线程中执行（通常都是这样），则应该使用StringBuilder。这两个类的API是一样的。 char charAt(int index)：返回给定位置的代码单元。 a.charAt(a.length() - 1 - i) - '0'：这里做减法是将两个的ASCII码值相减，如果是'9'-'0'就会得到整数值9。 'ans.append((char)(carry % 2 + ‘0’));'这里+'0'的原因是如果得到的值为整数值0，字符串什么也不会扩展，而如果是字符‘0’，则会加在后面。如下所示： 12System.out.println((char)(0)); //prints nothingSystem.out.println((char)(&#x27;0&#x27;)); // prints 0","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"53.最大子序和","date":"2021-05-17T09:03:00.000Z","path":"2021/05/17/LeetCode/53.最大子序和/","text":"官方链接 题目 题目描述 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 1： 123输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 12输入：nums &#x3D; [1]输出：1 示例 3： 123456输入：nums &#x3D; [0]输出：0示例 4：输入：nums &#x3D; [-1]输出：-1 示例 5： 12输入：nums &#x3D; [-100000]输出：-100000 提示： 1 &lt;= nums.length &lt;= 3 * 10410^4104 −105-10^5−105 &lt;= nums[i] &lt;= 10510^5105 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 方法一：暴力求解 既然要找到的最大的子序和，可以逐个遍历求出所有可能的子序列的和。 12345678910111213141516171819202122232425262728293031323334package leetcode;import java.util.Scanner;public class MaximumSubarray1 &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int[] nums = new int[n]; for(int l = 0; l &lt; n; l++) &#123; nums[l] = in.nextInt(); &#125; int thisSum = 0, maxSum = 0; for(int i = 0; i &lt; n; i++) // 子列的左端 &#123; for(int j = i; j &lt; n; j++) // 子列的右端 &#123; for(int k = i; k &lt;= j; k++) &#123; thisSum += nums[k]; &#125; if(thisSum &gt;= maxSum) &#123; maxSum = thisSum; &#125; thisSum = 0; &#125; &#125; System.out.println(maxSum); &#125;&#125; i 表示的是子列的左端，j表示的是子列的右端，再有一个指标k是从i~j，遍历可得该子序列的和，如果比maxSum大就更新最大子序和。 该方法有三层循环嵌套，如果NNN是该数组的长度，那么时间复杂度T(N)=O(N3)T(N)=O(N^3)T(N)=O(N3)。 方法二：方法一的改进 对于方法一中，相同的i，不同的j，可以逐步计算子序和，然后和maxSum比较，可以少一重循环。 12345678910111213141516171819202122232425262728293031package leetcode;import java.util.Scanner;public class MaximumSubarray2 &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int[] nums = new int[n]; for(int l = 0; l &lt; n; l++) &#123; nums[l] = in.nextInt(); &#125; int thisSum = 0, maxSum = nums[0]; for(int i = 0; i &lt; n; i++) // 子列的左端 &#123; thisSum = 0; for(int j = i; j &lt; n; j++) // 子列的右端 &#123; thisSum += nums[j]; if(thisSum &gt;= maxSum) &#123; maxSum = thisSum; &#125; &#125; &#125; System.out.println(maxSum); &#125;&#125; 由于该方法相比于方法一少一重循环，因此时间复杂度为T(N)=O(N2)T(N)=O(N^2)T(N)=O(N2)。 方法三：在线处理 “在线”的意思是指每输入一个数据就进行即时处理，在算法任何一个地方中止输入，算法都能正确给出当前的解。 在线处理的方法是不断向右累加，如果算出更大的和就更新最大子序和。需要注意的是由于我们计算的是最大子序和，因此一旦当前的子序和为负，肯定不能使得后面的部分增加，就需要将之抛弃。 1234567891011121314151617181920212223242526272829303132package leetcode;import java.util.Scanner;public class MaximumSubarray3 &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int[] nums = new int[n]; for(int l = 0; l &lt; n; l++) &#123; nums[l] = in.nextInt(); &#125; int thisSum = 0, maxSum = nums[0]; for(int i = 0; i &lt; n; i++) // 在线处理的方式 &#123; thisSum += nums[i]; System.out.println(&quot;i:&quot; + i + &quot;this sum:&quot; + thisSum); if(thisSum &gt; maxSum) &#123; maxSum = thisSum; &#125; if(thisSum &lt; 0) &#123; thisSum = 0; &#125; &#125; System.out.println(maxSum); &#125;&#125; 在线处理的方法的时间复杂度T(N)=O(N)T(N)=O(N)T(N)=O(N)。 参考资料 最大子序和的几种方法参考了中国大学MOOC课程数据结构1.3应用实例：最大子列和问题。","tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"分治算法","slug":"分治算法","permalink":"http://example.com/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"}]},{"title":"28.实现strStr()","date":"2021-05-16T15:25:00.000Z","path":"2021/05/16/LeetCode/28.实现strStr()/","text":"官网链接 题目 题目描述 实现strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例 1： 12输入：haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;输出：2 示例 2： 12输入：haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;输出：-1 示例 3： 12输入：haystack &#x3D; &quot;&quot;, needle &#x3D; &quot;&quot;输出：0 提示： 0 &lt;= haystack.length, needle.length &lt;= 5 * 10410^4104 haystack 和 needle 仅由小写英文字符组成 题解思路 先确定needle字符串的长度为n，然后遍历haystack字符串，在haystack取长度为n的子串，检查是否相等。 12345678910111213141516171819202122232425package leetcode;import java.util.Scanner;public class ImplementStr &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String haystack = in.next(); String needle = in.next(); int n = needle.length(); if(needle.equals(&quot;&quot;)) &#123; System.out.println(0); &#125; for(int i = 0; i &lt; haystack.length() - n + 1; i++) &#123; if(haystack.substring(i, i + n).equals(needle)) &#123; System.out.println(i); &#125; &#125; System.out.println(-1); &#125;&#125; 注意在Java中判断两个字符串是否相等应该有stra.equals(strb)，而stra == strb是判断这两个字符串所在的位置是否相同。","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"27.移除元素","date":"2021-05-15T14:35:00.000Z","path":"2021/05/15/LeetCode/27.移除元素/","text":"官网链接 题目 官方解答 题目描述 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 1234567&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len &#x3D; removeElement(nums, val);&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i &#x3D; 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 示例 1： 123输入：nums &#x3D; [3,2,2,3], val &#x3D; 3输出：2, nums &#x3D; [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。 示例 2： 123输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2输出：5, nums &#x3D; [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 1230 &lt;&#x3D; nums.length &lt;&#x3D; 1000 &lt;&#x3D; nums[i] &lt;&#x3D; 500 &lt;&#x3D; val &lt;&#x3D; 100 题解思路 双指针法。 left和right指针同时从数组左端开始遍历，从数组的左端到left指针所在的位置保证为所有不等于val的值，也就输出。 right如果和val不相等，则可以将right处的值赋给left的值，然后同时将left和right指针往后移位。 等right指针遍历完整个数组，则停止。 代码实现 123456789101112131415class Solution &#123; public int removeElement(int[] nums, int val) &#123; int n = nums.length; int left = 0; for(int right = 0; right &lt; n; right++) &#123; if(nums[right] != val) &#123; nums[left] = nums[right]; left++; &#125; &#125; return left; &#125;&#125;","tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"4.3 用户自定义类","date":"2021-05-14T12:52:00.000Z","path":"2021/05/14/coreJava1/4.3 用户自定义类/","text":"要想构建一个完整的程序，会结合使用多个类，其中只有一个类有main方法。 4.3.1 Employee类 程序清单 EmployeeTest.java 1234567891011121314151617181920212223242526/** * This program tests the Employee class * @version 1.13 2021-05-10 * @author jinjin */public class EmployeeTest &#123; public static void main(String[] args) &#123; // fill the staff array with three Employee objects Employee[] staff = new Employee[3]; staff[0] = new Employee(&quot;Carl Cracker&quot;, 75000, 1987, 12, 15); staff[1] = new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1); staff[2] = new Employee(&quot;Tony Tester&quot;, 40000,1990, 3, 15); // raise everyone&#x27;s salary by 5% for (Employee e : staff) e.raiseSalary(5); // print out information about all Employee objects for (Employee e : staff) System.out.println(&quot;name=&quot; + e.getName() + &quot;,salary=&quot; + e.getSalary() + &quot;,&quot; + &quot;hireDay=&quot; + e.getHireDay()); &#125;&#125; 程序清单 Employee.java 1234567891011121314151617181920212223242526272829303132333435import java.time.LocalDate;class Employee &#123; private final String name; private double salary; private LocalDate hireDay; public Employee(String n, double s, int year, int month, int day) &#123; name = n; salary = s; hireDay = LocalDate.of(year, month, day); &#125; public String getName() &#123; return name; &#125; public double getSalary() &#123; return salary; &#125; public LocalDate getHireDay() &#123; return hireDay; &#125; public void raiseSalary(double byPercent) &#123; double raise = salary * byPercent / 100; salary += raise; &#125;&#125; 源文件名是EmployeeTest.java，这是因为文件名必须与public类的名字相匹配。 在一个文件中，只能有一个公共类，但可以有任意数目的非公共类。 4.3.2 多个源文件的使用 可以将每一个类存放在一个单独的源文件中。 可以有两种编译源程序的方法。一种是使用通配符调用Java编译器：javac Employee*.java 第二种方法是：javac EmployeeTest.java 4.3.3 剖析Employee类 关键字public意味着任何类的任何方法都可以调用这些方法。 关键字private确保只有Employee类自身的方法能够访问这些实例字段，而其他类的方法不能够读写这些字段。 强烈建议将实例字段标记为private。 一种情况十分常见：类包含的实例字段通常属于某个类类型。 4.3.4 从构造器开始 123456public Employee(String n, double s, int year, int month, int day) &#123; name = n; salary = s; hireDay = LocalDate.of(year, month, day); &#125; 构造器与类同名。 在构造Employee类的对象时，构造器会运行，从而将实例字段初始化为所希望的初始状态。 构造器与其他方法有一个重要的不同。构造器总是结合new运算符来调用。不能对一个已经存在的对象调用构造器来达到重新设置实例字段的目的。 每个类可以有一个以上的构造器。 构造器可以有0个、1个或多个参数。 构造器没有返回值。 不要在构造器中定义域实例字段同名的局部变量。 必须注意在所有的方法中都不要使用与实例字段同名的变量。 4.3.5 用var声明局部变量 在Java10中，如果可以从变量的初始值推导出它们的类型，那么可以用var关键字声明局部变量，而无须指定类型。 注意var关键字只能用于方法中的局部变量。参数和字段的类型必须声明。 4.3.6 使用null引用 如果对null值应用一个方法，会产生一个NullPointerException异常。 定义一个类时，最好清楚知道哪些字段可能为null。 如果要接受一个对象引用作为构造参数，就要问问自己：是不是真的希望接受可有可无的值。如果不是，那么“严格型”方法更合适。 4.3.7 隐式参数与显式参数 在每一个方法中，关键字this指示隐式参数。 4.3.8 封装的优点 当想要获得或设置实例字段的值时，需要提供下面三项内容： 一个私有的数据字段； 一个公共的字段访问器方法； 一个公共的字段更改器方法。 这么做的好处： 可以改变内部实现； 更改器方法可以完成错误检查，而只对字段赋值的代码可能没有这个麻烦。 注意不要编写返回可变对象引用的访问器方法。 4.3.9 基于类的访问权限 一个方法可以访问所属类的所有对象的私有数据。 4.3.10 私有方法 重点在于，只要方法是私有的，类的设计者就可以确信它不会在别处使用，所以可以将其删去。 4.3.11 final实例字段 final修饰符对于类型为基本类型或者不可变类的字段尤其有用。","tags":[{"name":"《Java核心技术卷I 基础知识》","slug":"《Java核心技术卷I-基础知识》","permalink":"http://example.com/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%8B/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"12.整数转罗马数字","date":"2021-05-14T09:15:00.000Z","path":"2021/05/14/LeetCode/12.整数转罗马数字/","text":"官方链接 题目 官方解答 题目描述 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给你一个整数，将其转为罗马数字。 示例 1: 12输入: num &#x3D; 3输出: &quot;III&quot; 示例 2: 12输入: num &#x3D; 4输出: &quot;IV&quot; 示例 3: 输入: num = 9 输出: “IX” 示例 4: 123输入: num &#x3D; 58输出: &quot;LVIII&quot;解释: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3. 示例 5: 123输入: num &#x3D; 1994输出: &quot;MCMXCIV&quot;解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4. 提示： 11 &lt;&#x3D; num &lt;&#x3D; 3999 题解思路 考虑特殊情况后，可以得到总共以下13种情况： 1234567891011121314字符 数值M 1000CM 900D 500CD 400C 100XC 90L 50XL 40X 10IX 9V 5IV 4I 1 如果要用罗马数字表示一个数，如1994，首先考虑的是能表示的最大符号“M”，接着还剩下994，再考虑能表示的最大符号900，也就是“CM”，此时剩下90，“XC”，最后是4，“IV”。该过程就是在表示一个数xxx的过程中，先尽可能的用不超过xxx的最大数n1n_1n1​对应的罗马字符表示，再接着用罗马字符表示x−n1x-n_1x−n1​，依次进行，直到将xxx全部表示完。 代码 Java代码： 1234567891011121314151617class Solution &#123; public String intToRoman(int num) &#123; int[] values = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; String[] symbol = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;; StringBuilder builder = new StringBuilder(); while (num != 0) &#123; for (int i = 0; i &lt; values.length; i++) &#123; if (num &gt;= values[i]) &#123; builder.append(symbol[i]); num -= values[i]; break; &#125; &#125; &#125; return builder.toString(); &#125;&#125; 构建字符串 在代码中，需要用许多小段的字符串来构建一个字符串，步骤如下： 首先构建一个空的字符串构建器：StringBuilder builder = new StringBuilder();。 当每次需要添加一部分内容时，就调用append方法。 12builder.append(ch); // appends a single characterbuilder.append(str); // appends a string 在字符串构建完成时就调用toString方法，将可以得到一个String对象，其中包含了构建器中的字符序列。 1String completedStrinf = builder.toString();","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode中等","slug":"LeetCode中等","permalink":"http://example.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"1.两数之和","date":"2021-05-11T03:46:00.000Z","path":"2021/05/11/LeetCode/1.两数之和/","text":"官方链接 题目 官方解答 题目描述 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。 示例 2： 12输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2] 示例 3： 12输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 10310^3103 −109-10^9−109 &lt;= nums[i] &lt;= 10910^9109 −109-10^9−109 &lt;= target &lt;= 10910^9109 只会存在一个有效答案. 解答思路 方法一：暴力解法 方法二：哈希表，参考官方解答 代码实现 哈希表方法实现的代码如下： 12345678910111213141516171819202122232425262728package leetcode;import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class TwoSum2 &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int target = in.nextInt(); int[] result = new int[2]; int n = in.nextInt(); int[] nums = new int[n]; for (int i = 0; i &lt; n; i++) &#123; nums[i] = in.nextInt(); &#125; Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0; i &lt; n; i++)&#123; if(hashtable.containsKey(target - nums[i]))&#123; result[0] = hashtable.get(target - nums[i]); result[1] = i; &#125; hashtable.put(nums[i], i); &#125; System.out.println(result[0] + &quot; &quot; + result[1]); &#125;&#125;","tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"}]},{"title":"1734.解码异或后的排列","date":"2021-05-11T03:32:00.000Z","path":"2021/05/11/LeetCode/1734.解码异或后的排列/","text":"官方链接 题目 官方解答 题目描述 给你一个整数数组perm ，它是前n个正整数的排列，且n是个奇数。 它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。 给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。 示例 1： 123输入：encoded &#x3D; [3,1]输出：[1,2,3]解释：如果 perm &#x3D; [1,2,3] ，那么 encoded &#x3D; [1 XOR 2,2 XOR 3] &#x3D; [3,1] 示例 2： 12输入：encoded &#x3D; [6,5,4,6]输出：[2,4,1,5,3] 提示： 3 &lt;= n &lt; 10510^5105 n 是奇数。 encoded.length == n - 1 异或运算 关于位运算可以参看这里。 异或运算的几条性质： （1）交换律； （2）结合律：a⊕(b⊕c)=(a⊕b)⊕ca \\oplus (b \\oplus c)=(a \\oplus b) \\oplus ca⊕(b⊕c)=(a⊕b)⊕c； （3）对于任何数xxx，都有x⊕x=0,x⊕0=xx \\oplus x = 0,x \\oplus 0 = xx⊕x=0,x⊕0=x； （4）自反性：a⊕b⊕b=a⊕0=aa \\oplus b \\oplus b = a \\oplus 0 = aa⊕b⊕b=a⊕0=a。 题解思路 注意题中的条件有：给你一个整数数组perm ，它是前n个正整数的排列，且n是个奇数。 由于整数数组perm是前n个正整数的排列，因此可得 total=perm[0]⊕perm[1]⊕⋯⊕perm[n−1]=1⊕2⊕⋯⊕ntotal = perm[0] \\oplus perm[1] \\oplus \\cdots \\oplus perm[n-1] = 1 \\oplus 2 \\oplus \\cdots \\oplus n total=perm[0]⊕perm[1]⊕⋯⊕perm[n−1]=1⊕2⊕⋯⊕n 现在我们知道encoded数组，满足encoded[i] = perm[i] XOR perm[i+1]，因此 odd=perm[1]⊕perm[2]⊕perm[3]⊕⋯⊕perm[n−2]⊕perm[n−1]=(perm[1]⊕perm[2])⊕(perm[3]⊕perm[4])⊕⋯⊕(perm[n−2]⊕perm[n−1])=encoded[1]⊕encoded[3]⊕⋯⊕encoded[n−2]odd=perm[1] \\oplus perm[2] \\oplus perm[3] \\oplus \\cdots \\oplus perm[n-2] \\oplus perm[n-1] \\\\ =(perm[1] \\oplus perm[2] )\\oplus (perm[3] \\oplus perm[4])\\oplus \\cdots \\oplus (perm[n-2] \\oplus perm[n-1]) \\\\ =encoded[1] \\oplus encoded[3] \\oplus \\cdots \\oplus encoded[n-2] odd=perm[1]⊕perm[2]⊕perm[3]⊕⋯⊕perm[n−2]⊕perm[n−1]=(perm[1]⊕perm[2])⊕(perm[3]⊕perm[4])⊕⋯⊕(perm[n−2]⊕perm[n−1])=encoded[1]⊕encoded[3]⊕⋯⊕encoded[n−2] 将上式与total异或可以得到total⊕odd=perm[0]total \\oplus odd = perm[0]total⊕odd=perm[0]。当知道perm[0]后就能计算数组中其他元素: perm[i]=encoded[i−1]⊕perm[i−1],1≤i≤n−1perm[i] = encoded[i - 1] \\oplus perm[i - 1],\\quad 1 \\le i \\le n-1 perm[i]=encoded[i−1]⊕perm[i−1],1≤i≤n−1 Java代码如下： 123456789101112131415161718192021class Solution &#123; public int[] decode(int[] encoded) &#123; int n = encoded.length + 1; int[] perm = new int[n]; int total = 0; // 注意perm是前n个正整数的排列 for (int i = 1; i &lt;= n; i++) &#123; total ^= i; &#125; int odd = 0; for (int i = 1; i &lt; n - 1; i = i + 2) &#123; odd ^= encoded[i]; &#125; perm[0] = total ^ odd; for (int i = 1; i &lt; n; i++) &#123; perm[i] = encoded[i - 1] ^ perm[i - 1]; &#125; return perm; &#125;&#125; 复杂度分析 时间复杂度：O(n)O(n)O(n) 空间复杂度：O(1)O(1)O(1)","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode中等","slug":"LeetCode中等","permalink":"http://example.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"4.1 面向对象程序设计概述-4.2 使用预定义类","date":"2021-05-10T06:16:00.000Z","path":"2021/05/10/coreJava1/4.1 面向对象程序设计概述-4.2 使用预定义类/","text":"4.1 面向对象程序设计概述 面向对象程序设计：object-oriented programming, OOP 面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。 OOP将数据放在第一位，然后再考虑操作数据的算法。 面向对象更加适合解决规模较大的问题。 4.1.1 类 类是构造对象的模板和蓝图。 由类构造对象的过程称为创建类的实例。 封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。 对象中的数据称为实例字段，操作数据的过程称为方法。 作为一个类的实例，特定对象都有一组特定的实例字段值。这些值的集合就是这个对象的当前状态。 在Java中，所有类都源自一个“神通广大的超类”，就是Object。 通过扩展一个类来建立另外一个类的过程为继承。 4.1.2 对象 对象的三个主要特性：行为、状态、标识。 对象的行为是用可调用的方法来定义的。 每个对象都保存着描述当前状况的信息，这就是对象的状态。 对象状态的改变必须通过调用方法实现，否则破坏了封装性。 每个对象都有一个唯一的标识。 作为同一个类的实例，每个对象的标识总是不同的，状态也往往存在着差异。 4.1.3 识别类 OOP学习中，首先从识别类开始，然后再为各个类添加方法。 经验：类——名词，方法——动词。 4.1.4 类之间的关系 在类之间，常见的关系：依赖、聚合、继承。 如果一个类的方法使用或操纵另一个类的对象，我们就说一个类依赖于另一个类。 应该尽可能地将相互依赖的类减至最少，减少类之间的耦合。 包容关系意味着类A的对象包含类B的对象。 4.2 使用预定义类 4.2.1 对象与对象变量 要想使用对象，首先必须构造对象，并制定其初始状态。然后对对象应用方法。 构造器的名字应该与类名相同。 对象变量并没有实际包含一个对象，它只是引用一个对象。 在Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的应用。new操作符的返回值也是一个引用。 可以显示地将对象变量设置为null，指示这个对象变量目前没有引用任何对象。 4.2.2 Java类库中的LocalDate类 用来表示时间点：Data类。 用大家熟悉的日历表示日期：LocalDate类。 不要使用构造器来构造LocalDate类的对象，实际上，应当使用静态工厂方法，它会代表你调用构造器。LocalDate.now()会构造一个新对象。 LocalDate类封装了实例字段来维护所设置的日期。 4.2.3 更改器方法与访问器方法 只访问对象而不修改对象的方法有时称为访问器方法。 CalendarTest.java 1234567891011121314151617181920212223242526272829303132333435import java.time.DayOfWeek;import java.time.LocalDate;/** * @version 1.5 2021-05-09 * @author jinjin */public class CalendarTest &#123; public static void main(String[] args) &#123; LocalDate date = LocalDate.now(); int month = date.getMonthValue(); int today = date.getDayOfMonth(); date = date.minusDays(today - 1); // set to start of month DayOfWeek weekday = date.getDayOfWeek(); int value = weekday.getValue(); // 1 = Monday, . . . , 7 = Sunday System.out.println(&quot;Mon Tue Wed Thu Fir Sat Sun&quot;); for (int i = 1; i &lt; value; i++) System.out.print(&quot; &quot;); while (date.getMonthValue() == month) &#123; System.out.printf(&quot;%3d&quot;, date.getDayOfMonth()); if (date.getDayOfMonth() == today) System.out.print(&quot;*&quot;); else System.out.print(&quot; &quot;); date = date.plusDays(1); if (date.getDayOfWeek().getValue() == 1) System.out.println(); &#125; if (date.getDayOfWeek().getValue() != 1) System.out.println(); &#125;&#125;","tags":[{"name":"《Java核心技术卷I 基础知识》","slug":"《Java核心技术卷I-基础知识》","permalink":"http://example.com/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%8B/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"198.打家劫舍","date":"2021-05-10T01:44:00.000Z","path":"2021/05/10/LeetCode/198.打家劫舍/","text":"官方链接 题目 官方解答 题目描述 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。 示例 1： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 示例 2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。 偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。 提示： 121 &lt;&#x3D; nums.length &lt;&#x3D; 100 0 &lt;&#x3D; nums[i] &lt;&#x3D; 400 题解思路 动态规划 设dp[i]表示到第[i]家能偷窃得到的最高金额。 我们知道如果i=0，那么只有一个房间，于是dp[0]=nums[0]。 如果i=1，那么有两个房间，最高金额应该是dp[1]=max(nums[0],nums[1])。 如果i=2,则有三个房间，如果偷第三间房，则金额为dp[0]+nums[2]，如果不偷第三间房，则见好就收，最高金额为dp[1]，因此dp[2]=max(dp[0]+nums[2], dp[1])。 … 最终可得到递推公式 dp[i]=max(dp[i−2]+nums[i],dp[i−1])dp[i] = max(dp[i-2] + nums[i], dp[i-1]) dp[i]=max(dp[i−2]+nums[i],dp[i−1]) 根据递推公式编写代码如下： 123456789101112131415class Solution &#123; public int rob(int[] nums) &#123; int n = nums.length; int[] dp = new int[n]; if (n == 1) return nums[0]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2 ; i &lt; n; i++) &#123; dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]); &#125; return dp[n - 1]; &#125;&#125; 设nums[]长度为NNN，则时间复杂度为O(N)O(N)O(N)，空间复杂度为O(N)O(N)O(N)。 动态规划+滚动数组 在上述动态规划方法中，状态数组dp[]并不需要都记录，只需要记录dp[i]的前两项dp[i-1]和dp[i-2]。 12345678910111213141516class Solution &#123; public int rob(int[] nums) &#123; int n = nums.length; if (n == 1) return nums[0]; int tempt = 0; int first = nums[0]; int second = Math.max(first, nums[1]); for(int i = 2; i &lt; n; i++) &#123; tempt = second; second = Math.max(second, first + nums[i]); first = tempt; &#125; return second; &#125;&#125; 此时时间复杂度为O(N)O(N)O(N)，空间复杂度为O(1)O(1)O(1)。","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode中等","slug":"LeetCode中等","permalink":"http://example.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"3.10 数组","date":"2021-05-09T12:48:00.000Z","path":"2021/05/09/coreJava1/3.10 数组/","text":"3.10.1 声明数组 数组是一种数据结构，用来存储同一类型值得集合。 一旦创建了数组，就不能再改变它的长度。如果程序运行中需要经常扩展数组的大小，就应该使用另一种数据结构——数组列表（array list）。 创建数组对象并同时提供初始值的简写形式：int[] smallPrimes = &#123; 2, 3, 5, 7, 11, 13, &#125;; 在Java中，允许有长度为0的数组。长度为0的数组与null并不相同。 3.10.2 访问数组元素 创建一个数字数组时，所有元素都初始化为0. boolean数组的元素初始化为false。 对象数组的元素初始化为一个特殊值null，表示这些元素（还）为存放任何对象。 3.10.3 for each 循环 依次处理数组中的每个元素，而不必考虑指定下标值：for (variable : collection) statement 更加简单的方式打印数组中的所有值：System.out.println(Arrays.toString(a)); 3.10.4 数组拷贝 如果希望讲一个数组的所有值拷贝到一个新的数组中去，要使用Arrays类的copyOf方法： 1int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length); 第2个参数是新数组的长度，这个方法可以用来增加数组的大小。 3.10.5 命令行参数 在Java应用程序的main方法中，程序名并没有存储在args数组中。 3.10.6 数组排序 程序清单LotteryDrawing.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Arrays;import java.util.Scanner;/** * This program demonstrates array manipulation. * @version 1.20 2021-05-09 * @author jinjin */public class LotteryDrawing &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.print(&quot;How many numbers do you need to draw? &quot;); int k = in.nextInt(); System.out.print(&quot;What is the highest number you can draw? &quot;); int n = in.nextInt(); // fill an array with numbers 1 2 3 ... n int[] numbers = new int[n]; for (int i = 0; i &lt; numbers.length; i++) numbers[i] = i + 1; // draw k numbers and put them into a second array int[] result = new int[k]; for (int i = 0; i &lt; result.length; i++) &#123; // make a random index between 0 and n - 1 int r = (int) (Math.random() * n); // pick the element at the random location result[i] = numbers[r]; // move the last element into the random location numbers[r] = numbers[n - 1]; n--; &#125; // print the sorted array Arrays.sort(result); System.out.println(&quot;Bet the following combination. It&#x27;ll make you rich!&quot;); for (int r : result) System.out.println(r); &#125;&#125; 3.10.7 多维数组 程序清单CompoundInterest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * This program shows how to store tabular data in a 2D array * @version 1.40 2021-05-09 * @author jinjin */public class CompoundInterest &#123; public static void main(String[] args) &#123; final double STARTRATE = 10; final int NRATES = 6; final int NYEAS = 10; // set interest rate to 10 ... 15% double[] interestRate = new double[NRATES]; for (int j = 0; j &lt; interestRate.length; j++) interestRate[j] = (STARTRATE + j) / 100.0; double[][] balances = new double[NYEAS][NRATES]; // set initial balances to 10000 for (int j = 0; j &lt; balances[0].length; j++) balances[0][j] = 10000; // compute interest for future years for (int i = 1; i &lt; balances.length; i++) &#123; for (int j = 0; j &lt; balances[i].length; j++) &#123; // get last year&#x27;s balances from previous row double oldBalance = balances[i - 1][j]; // compute interest double interest = oldBalance * interestRate[j]; // compute this year&#x27;s balances balances[i][j] = oldBalance + interest; &#125; &#125; // print one row of interest rates for (int j = 0; j &lt; interestRate.length; j++) System.out.printf(&quot;%9.0f%%&quot;, 100 * interestRate[j]); System.out.println(); // print balance table for (double[] row : balances) &#123; // print table row for (double b : row) System.out.printf(&quot;%10.2f&quot;, b); System.out.println(); &#125; &#125;&#125; 3.10.8 不规则数组 Java实际上没有多维数组，只有一维数组。多维数组被解释为“数组的数组”。 程序清单LotteryArray.java 1234567891011121314151617181920212223242526272829303132333435363738/** * This program demonstrates a triangular array. * @version 1.20 2021-05-09 * @author jinjin */public class LotteryArray &#123; public static void main(String[] args) &#123; final int NMAX = 10; // allocate triangular array int[][] odds = new int[NMAX + 1][]; for (int n = 0; n &lt;= NMAX; n++) odds[n] = new int[n + 1]; // fill triangular array for (int n = 0; n &lt; odds.length; n++) for (int k = 0; k &lt; odds[n].length; k++) &#123; /* * compute binomial coefficient n*(n-1)*(n-2)*...*(n-k+1)/(1*2*3*...*k) */ int lotteryOdds = 1; for (int i = 1; i &lt;= k; i++) lotteryOdds = lotteryOdds * (n - i + 1) / i; odds[n][k] = lotteryOdds; &#125; // print triangular array for (int[] row : odds) &#123; for (int odd : row) System.out.printf(&quot;%4d&quot;, odd); System.out.println(); &#125; &#125;&#125;","tags":[{"name":"《Java核心技术卷I 基础知识》","slug":"《Java核心技术卷I-基础知识》","permalink":"http://example.com/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%8B/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"3.8 控制流程-3.9 大数","date":"2021-05-09T09:59:00.000Z","path":"2021/05/09/coreJava1/3.8 控制流程-3.9 大数/","text":"3.8 控制流程 Remark 块确定了变量的作用域。 不能在嵌套的两个块中声明相同名的变量。 for语句的第1部分通常是对计数器初始化；第2部分给出每次新一轮循环执行前要检测的循环条件；第3部分指定如何更新计数器。 for语句的3各部分应该对同一个计数器变量进行初始化、检测和更新。 在循环中，检测两个浮点数是否相等需要格外小心，因为由于舍入误差，可能永远达不到精确的最终值。 如果在case分支语句的末尾没有break语句，哪门就会接着执行下一个case分支语句。这种情况相当危险，常常会引发错误。为此，我们在程序中从不使用switch语句。 程序清单 Retirement.java 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Scanner;/** * This program demonstrates a &lt;code&gt;while&lt;/code&gt; loop. * @version 1.20 2021-5-8 * @author jinjin * */public class Retirement &#123; public static void main(String[] args) &#123; // read inputs Scanner in = new Scanner(System.in); System.out.print(&quot;How much money do you need to retie? &quot;); double goal = in.nextDouble(); System.out.print(&quot;How much money will you contribute every year? &quot;); double payment = in.nextDouble(); System.out.print(&quot;Interest rate in %: &quot;); double interestRate = in.nextDouble(); double balance = 0; int years = 0; // update account balance while goal isn&#x27;t reached while(balance &lt; goal) &#123; // add this year&#x27;s payment and interest balance += payment; double interest = balance * interestRate / 100; balance += interest; years++; &#125; System.out.println(&quot;You can retire in &quot; + years + &quot; years.&quot;); &#125;&#125; Retirement2.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;/** * This program demonstrates a &lt;code&gt;do/while&lt;/code&gt; loop. * @version 1.20 2021-5-8 * @author jinjin */public class Retirement2 &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.print(&quot;How much money will you contribute every year? &quot;); double payment = in.nextDouble(); System.out.print(&quot;Interest rate in %: &quot;); double interestRate = in.nextDouble(); double balance = 0; int year = 0; String input; //update account balance while user isn&#x27;t ready to retire do &#123; // add this year&#x27;s payment and interest balance += payment; double interest = balance * interestRate / 100; balance += interest; year++; // print current balance System.out.printf(&quot;After year %d, your balance is %,.2f%n&quot;, year, balance); //ask if ready to retire and get input System.out.print(&quot;Ready to retire?(Y/N) &quot;); input = in.next(); &#125; while (input.equals(&quot;N&quot;)); &#125;&#125; LotteryOdds.java 12345678910111213141516171819202122232425262728293031package ch3;import java.util.Scanner;/** * This program demonstrates a &lt;code&gt;for&lt;/code&gt; loop. * @version 1.20 2021-05-09 * @author jinjin */public class LotteryOdds &#123; public static void main(String[] args)&#123; Scanner in = new Scanner(System.in); System.out.print(&quot;How many numbers do you need to draw? &quot;); int k = in.nextInt(); System.out.print(&quot;What is the highest number you can draw? &quot;); int n = in.nextInt(); /* * compute binomial coefficient n*(n-1)*(n-2)*...*(n-k+1)/(1*2*3*...*k) */ int lotteryOdds = 1; for(int i = 1; i &lt;= k; i++) lotteryOdds = lotteryOdds * (n - i + 1) / i; System.out.printf(&quot;You odds are 1 in %,d. Good luck!&quot;, lotteryOdds); &#125;&#125; 3.9 大数 Remark BigInteger类实现任意精度的整数运算，BigDecimal实现任意精度的浮点数运算。 使用静态的valueOf方法可以将普通的数值转换为大数：BigInteger a = BigInteger.valueOf(100); 不能使用人们熟悉的算术运算符处理大数，而需要使用大数类中的add和multiply方法。 程序清单 BigIntegerTest.java 123456789101112131415161718192021222324252627282930import java.math.BigInteger;import java.util.Scanner;/** * This program uses big numbers to compute the odds of winning the grand prize in a lottery. * @version 1.20 2021-05-09 * @author jinjin */public class BigIntegerTest &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.print(&quot;How many numbers do you need to draw? &quot;); int k = in.nextInt(); System.out.print(&quot;What is the highest number you can draw? &quot;); int n = in.nextInt(); /* * compute binomial coefficient n*(n-1)*(n-2)*..*(n-k+1)/(1*2*3*...*k) */ BigInteger lotteryOdds = BigInteger.valueOf(1); for (int i = 1; i &lt;= k; i++) lotteryOdds = lotteryOdds.multiply(BigInteger.valueOf(n - i + 1)).divide(BigInteger.valueOf(i)); System.out.printf(&quot;You odds are 1 in %,d. Good luck!&quot;, lotteryOdds); &#125;&#125;","tags":[{"name":"《Java核心技术卷I 基础知识》","slug":"《Java核心技术卷I-基础知识》","permalink":"http://example.com/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%8B/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"70.爬楼梯","date":"2021-05-09T09:25:00.000Z","path":"2021/05/09/LeetCode/70.爬楼梯/","text":"官方链接 题目 官方解答 题目描述 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 题解思路 设FnF_{n}Fn​表示爬nnn阶楼梯具有的方法个数，通过推算观察规律可以得到一个递推公式： Fn+1=Fn+Fn−1,n≥2F1=1,F2=2.F_{n+1}=F_n+F_{n-1}, \\quad n \\ge 2 \\\\ F_1 = 1, \\quad F_2 = 2. Fn+1​=Fn​+Fn−1​,n≥2F1​=1,F2​=2. 递归 根据递推公式可以编写递归程序。代码如下： 1234567891011121314class Solution &#123; public int climbStairs(int n) &#123; // 递归 if (n == 1) &#123; return 1; &#125; else if(n == 2) &#123; return 2; &#125; else if( n &gt; 2) &#123; return climbStairs(n - 1) + climbStairs(n - 2); &#125; &#125;&#125; 动态规划 用状态数组dp[n]记录FnF_nFn​，再用递推公式计算。 1234567891011121314151617class Solution &#123; public int climbStairs(int n) &#123; // 动态规划 状态数组 if (n == 1) return 1; else if (n == 2) return 2; else &#123; int[] dp = new int[n]; // 状态数组 dp[0] = 1; dp[1] = 2; for (int i = 2; i &lt; n; i++) &#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n-1]; &#125; &#125;&#125; 还可以使用滚动数组的方式，不需要申请一个数组的空间，需要用到三个变量。 12345678910111213141516class Solution &#123; public int climbStairs(int n) &#123; // 动态规划 int a1 = 1; // n = 1 时方案的个数 int a2 = 2; // n = 2 时方案的个数 int q = 0; // q 表示第n次的结果 if (n == 1) return a1; if (n == 2) return a2; for (int i = 3; i &lt;= n; i++) &#123; q = a1 + a2; a1 = a2; a2 = q; &#125; return q; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"3.7 输入与输出","date":"2021-05-08T14:00:00.000Z","path":"2021/05/08/coreJava1/3.7.1 读取输入/","text":"3.7.1 读取输入 通过控制台进行输入的步骤： 首先构造一个与“标准输入流”System.in关联的Scanner对象： Scanner in = new Scanner(); 使用Scanner类的各种方法读取输入： String name = in.nextLine(); Scanner类定义在java.util包中，使用时要用import导入。 Scanner类的常用方法 String nextLine():将读取一行输入 。 String next():读取输入的下一个单词（以空格作为分隔符）。 int nextInt() Consle类 Scanner类不适用于从控制台读取密码，此时可以用Consle类。 1234Consle cons = System.console();String username = cons.readLine(&quot;User name: &quot;);char[] passwd = cons.readPassword(&quot;Password: &quot;); 代码 12345678910111213141516171819202122232425262728import java.util.*;/** * This program demonstrates console input * @version 1.10 2021-05-08 * @author 文进 * */public class InputTest &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); // get first input System.out.print(&quot;What is your name? &quot;); String name = in.nextLine(); // get second input System.out.print(&quot;How old are you? &quot;); int age = in.nextInt(); // display output on console System.out.println(&quot;Hello, &quot; + name + &quot;.Next year, you&#x27;ll be &quot; + (age + 1)); &#125;&#125; 3.7.2 格式化输出 System.out.print(x);将以x的类型所允许的最大非0数位个数打印输出x。 System.out.print(&quot;%8.2f&quot;, x);字段宽度为8，包括8个字符，另外精度为小数点后2个字符，注意这里前导的空格也算一个字符。 每一个以%字符开始的格式说明符都用相应的参数替换。如：System.out.printf(&quot;Hello, %s. Next year, you'll be %d.&quot;,name, age + 1);,f表示浮点数，s表示字符串，d表示十进制整数。 还可以指定控制格式化输出外观的各种标志，如：System.out.printf(&quot;%,.2f&quot;, 10000.0 / 3.0); //prints 3,333.33 使用静态的String.format方法创建一个格式化的字符串，而不打印输出：String message = String.format(&quot;Hello, %s. Next year, you'll be %d.&quot;, name, age + 1); printf方法中有日期与时间格式化选项，如System.out.printf(&quot;%tc&quot;, new Date()); // prints 周六 5月 08 20:44:49 CST 2021 3.7.3 文件输入与输出 读取文件：Scanner in = new Scanner(Path.of(&quot;myfile.txt&quot;), StandardCharsets.UTF-8); 写入文件：PrintWriter out = new PrintWriter(&quot;myfile.txt&quot;, StandardCharsets.UTF_8);","tags":[{"name":"《Java核心技术卷I 基础知识》","slug":"《Java核心技术卷I-基础知识》","permalink":"http://example.com/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%8B/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"118.杨辉三角","date":"2021-05-08T11:25:09.000Z","path":"2021/05/08/LeetCode/118.杨辉三角/","text":"官方链接 题目描述 官方解答 题目描述 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 题解思路 在杨辉三角中，每个数是它左上方和右上方的数的和，根据这一点，可以先生成第iii行的元素，再生成第i+1i+1i+1行的元素。 代码 123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i = 0; i &lt; numRows; i++)&#123; List&lt;Integer&gt; row = new ArrayList&lt;Integer&gt;(); for(int j = 0; j &lt;= i; j++)&#123; if(j == 0 || j == i)&#123; row.add(1); &#125; else&#123; row.add(ret.get(i - 1).get(j - 1) + ret.get(i - 1).get(j)); &#125; &#125; ret.add(row); &#125; return ret; &#125;&#125;","tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"}]},{"title":"1468.数组异或操作","date":"2021-05-07T02:49:09.000Z","path":"2021/05/07/LeetCode/1468.数组异或操作/","text":"官方链接 1468.数组异或操作 题目描述 给你两个整数，n 和 start 。 数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。 请返回 nums 中所有元素按位异或（XOR）后得到的结果。 示例 1： 1234输入：n &#x3D; 5, start &#x3D; 0输出：8解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) &#x3D; 8 。 &quot;^&quot; 为按位异或 XOR 运算符。 示例 2： 123输入：n &#x3D; 4, start &#x3D; 3输出：8解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) &#x3D; 8. 示例 3： 12输入：n &#x3D; 1, start &#x3D; 7输出：7 示例 4： 12输入：n &#x3D; 10, start &#x3D; 5输出：2 提示： 1 &lt;= n &lt;= 1000 0 &lt;= start &lt;= 1000 n == nums.length 题解思路 异或运算规则为相同为0，相异为1. 可以遍历每一个元素，依次做异或运算。 代码 1234567891011class Solution &#123; public int xorOperation(int n, int start) &#123; int result = start; for(int i = 1; i &lt; n; i++) &#123; result = result ^ (start + 2 * i); &#125; return result; &#125;&#125;","tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"1720.解码异或后的数组","date":"2021-05-06T03:08:09.000Z","path":"2021/05/06/LeetCode/1720.解码异或后的数组/","text":"官方链接 1720.解码异或后的数组 题目描述 未知 整数数组 arr 由 n 个非负整数组成。 经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。 给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。 请解码返回原数组 arr 。可以证明答案存在并且是唯一的。 示例 1： 123输入：encoded &#x3D; [1,2,3], first &#x3D; 1输出：[1,0,2,1]解释：若 arr &#x3D; [1,0,2,1] ，那么 first &#x3D; 1 且 encoded &#x3D; [1 XOR 0, 0 XOR 2, 2 XOR 1] &#x3D; [1,2,3] 示例 2： 12输入：encoded &#x3D; [6,2,7,3], first &#x3D; 4输出：[4,2,0,7,4] 提示： 2 &lt;= n &lt;= 104 encoded.length == n - 1 0 &lt;= encoded[i] &lt;= 10510^5105 0 &lt;= first &lt;= 10510^5105 题解思路 在异或运算中，相同为0，相异为1，即 0⊕0=01⊕0=11⊕1=00⊕1=10 \\oplus 0 = 0 \\\\ 1 \\oplus 0 = 1 \\\\ 1 \\oplus 1 = 0 \\\\ 0 \\oplus 1 = 1 0⊕0=01⊕0=11⊕1=00⊕1=1 根据题意，我们现在得到的是异或后的结果，也就是上面异或运算法则等号后的数，即第三列。由于知道原来数组中的第一个元素，可以理解为知道上述异或运算法则的第一列，现在看如何知道第二列。设这个运算为新异或运算，标记为⊕′\\oplus&#x27;⊕′，则有规则如下： 0⊕′0=01⊕′1=00⊕′1=11⊕′0=10 \\oplus&#x27; 0 = 0\\\\ 1 \\oplus&#x27; 1 = 0\\\\ 0 \\oplus&#x27; 1 = 1\\\\ 1 \\oplus&#x27; 0 = 1 0⊕′0=01⊕′1=00⊕′1=11⊕′0=1 在上述法则中，可以发现规律，相同为0，不同为1，从而得到⊕′\\oplus&#x27;⊕′为异或运算。因此解码过程为逐个进行异或运算。 在Java中，a与b的异或为a^b。 代码 12345678910111213class Solution &#123; public int[] decode(int[] encoded, int first) &#123; int n = encoded.length; int[] ans = new int[n + 1]; ans[0] = first; for(int i = 0; i &lt; n; i++) &#123; ans[i+1] = ans[i] ^ encoded[i]; &#125; return ans; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"http://example.com/tags/LeetCode%E7%AE%80%E5%8D%95/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"633.平方数之和","date":"2021-04-28T11:56:09.000Z","path":"2021/04/28/LeetCode/633.平方数之和/","text":"官方链接 题目描述 官方题解 题目描述 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2+b2=ca^2 + b^2 = ca2+b2=c。 示例 1： 123输入：c &#x3D; 5输出：true解释：1 * 1 + 2 * 2 &#x3D; 5 示例 2： 12输入：c &#x3D; 3输出：false 示例 3： 12输入：c &#x3D; 4输出：true 示例 4： 12输入：c &#x3D; 2输出：true 示例 5： 12输入：c &#x3D; 1输出：true 提示： 0≤c≤231−10 \\le c \\le 2^{31} - 10≤c≤231−1 题解思路 所给的非负整数为ccc，那么要找的两个数aaa和bbb的范围肯定为[0,c][0,\\sqrt{c}][0,c​]。首先第一个整数aaa在[0,c][0,\\sqrt{c}][0,c​]之间遍历，当aaa确定后，b=c2−a2b=\\sqrt{c^2-a^2}b=c2−a2​，再确定整数bbb，在这个过程中，有可能需要强制转换类型，会直接截断，因此还需要进一步检验，如果有c=a2+b2c=a^2+b^2c=a2+b2，则返回true。 时间复杂度：O(c)O(\\sqrt{c})O(c​) 空间复杂度：O(1)O(1)O(1) 代码实现 123456789101112class Solution &#123; public boolean judgeSquareSum(int c) &#123; int n = (int)Math.sqrt(c); for(int i = n; i &gt;= 0; i--) &#123; int tempt = (int)Math.sqrt(c - i * i); if(tempt * tempt + i * i == c) &#123; return true; &#125; &#125; return false; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode中等","slug":"LeetCode中等","permalink":"http://example.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"1101.在D天内送达包裹的能力","date":"2021-04-28T11:04:09.000Z","path":"2021/04/28/LeetCode/1101.在D天内送达包裹的能力/","text":"官网链接 题目 官方解答 题目描述 传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。 传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。 返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。 示例 1： 1234567891011输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5输出：15解释：船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：第 1 天：1, 2, 3, 4, 5第 2 天：6, 7第 3 天：8第 4 天：9第 5 天：10请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 示例 2： 1234567输入：weights &#x3D; [3,2,2,4,1,4], D &#x3D; 3输出：6解释：船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：第 1 天：3, 2第 2 天：2, 4第 3 天：1, 4 示例 3： 1234567输入：weights &#x3D; [1,2,3,1,1], D &#x3D; 4输出：3解释：第 1 天：1第 2 天：2第 3 天：3第 4 天：1, 1 提示： 121 &lt;&#x3D; D &lt;&#x3D; weights.length &lt;&#x3D; 500001 &lt;&#x3D; weights[i] &lt;&#x3D; 500 题解思路 二分查找的思想，根据题目的描述，可以确定合适的船运载量应该在区间[weights中最大元素，weights所有元素之和]，设二分区间为[left,right]。现在需要计算对于船运载量为xxx时，所需的天数是多少，用needDay表示。不断二分区间[left,right]，计算needDay，与所要求的天数D进行比较。 如果needDay &gt; D，说明当前运载量小了，合适的运载量在区间[mid + 1, right],需要让left = mid + 1。 如果needDay &lt;= D,说明当前运载量大了或者合适，合适的运载量在区间[left, mid],需要让right = mid。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package leetcode;import java.util.Arrays;import java.util.Scanner;public class CapacityToShipPackagesWithinDDays &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int D = in.nextInt(); int n = in.nextInt(); int[] weights = new int[n]; for(int i = 0; i &lt; n; i++) &#123; weights[i] = in.nextInt(); &#125; Solution s = new Solution (); System.out.println(s.shipWithinDays(weights, D)); &#125;&#125;class Solution &#123; public int shipWithinDays(int[] weights, int D) &#123; // 确定二分查找左右边界 int left = Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum(); while(left &lt; right) &#123; int mid = (left + right) / 2; // need 为需要运送的天数 // cur 为当前这一天已经运算的包裹重量之和 int need = 1, cur = 0; for(int weight : weights) &#123; if(cur + weight &gt; mid) &#123; ++need; cur = 0; &#125; cur += weight; &#125; if(need &lt;= D) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"LeetCode中等","slug":"LeetCode中等","permalink":"http://example.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"},{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"LeetCode题目汇总","date":"2021-04-28T11:01:09.000Z","path":"2021/04/28/LeetCode/LeetCode题目汇总/","text":"1-50 1.两数之和 #简单 #数组 #哈希表 12.整数转罗马数字 #中等 #数学 #字符串 22.括号生成 #中等 #字符串 #回溯算法 27.移除元素 #简单 #数组 #双指针 28.实现strStr() #简单 #双指针 #字符串 51-100 53.最大子序和 #简单 #数组 #分治算法 #动态规划 67.二进制求和 #简单 #数学 #字符串 69.x的平方根 #简单 #数学 #二分查找 70.爬楼梯 #简单 #动态规划 91.解码方法 #中等 #字符串 #动态规划 101-150 118.杨辉三角 #简单 #数组 121.买卖股票的最佳时机 #简单 #数组 #动态规划 151-1000 198.打家劫舍 #中等 #动态规划 461.汉明距离 #简单 #位运算 368.最大整除子集 #中等 #数学 #动态规划 633.平方数之和 #中等 #数学 1000-… 1035.不相交的线 #中等 #数组 1277.统计全为1的正方形子矩阵 #中等 #数组 #动态规划 1101.在D天内送达包裹的能力 #中等 #二分查找 1442.形成两个异或相等数组的三元数组 #中等 #位运算 #数组 #数学 1468.数组异或操作 #简单 #位运算 #数组 1720.解码异或后的数组 #简单 #位运算 1734.解码异或后的排列 #中等 #位运算","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"目录","slug":"目录","permalink":"http://example.com/tags/%E7%9B%AE%E5%BD%95/"}]},{"title":"3.5运算符-3.6字符串","date":"2021-04-16T13:06:00.000Z","path":"2021/04/16/coreJava1/3.5运算符-3.6字符串/","text":"3.5 运算符 3.5.1 算术运算符 算术运算符+、-、*、/表示加、减、乘、除运算。 当参与/运算的两个操作数都是整数时，表示整数除法，否则，表示浮点除法。 整数的求余操作%。 整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或NaN结果。 3.5.2 数学函数与常量 Math类中的sqrt方法并不处理任何对象，这样的方法被称为静态方法。 pow方法有两个double类型的参数，其返回结果也为double类型。 12345678910public class UseMath &#123; public static void main(String[] args) &#123; double x = 4; double y = Math.sqrt(x); double z = Math.pow(x, 2); System.out.println(y); // prints 2.0 System.out.println(z); // prints 16.0 &#125;&#125; 也可以在源文件的顶部加上import static java.lang.Math.*;。 1234567891011import static java.lang.Math.*;public class UseMath &#123; public static void main(String[] args) &#123; double x = 4; double y = sqrt(x); double z = pow(x, 2); System.out.println(y); // prints 2.0 System.out.println(z); // prints 16.0 &#125;&#125; floorMod方法的目的是解决一个长期存在的有关整数余数的问题。考虑表达式n%2，如果n为负且为奇数，这个表达式则为-1。实际上根据欧几里得规则，余数总是要≥0\\ge0≥0。floorMod(position + adjustment, 12)总会得到一个0~11之间的数。（遗憾的是，对于负除数，floorMod会得到负数结果，不过这种情况在实际中很少出现。） 三角函数： 12345Math.sinMath.cosMath.tanMath.atanMath.atan2 指数函数及它的反函数 123Math.expMath.logMath.log10 Java提供两个用于表示π\\piπ和eee常量的最接近的近似值： 12Math.PIMath.E 3.5.3 数值类型之间的转换 当用一个二元运算符连接两个值时，先要将两个操作数转换为同一种类型，然后再进行计算。 3.5.4 强制类型转换 强制类型转换的语法格式是在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名。 强制类型转换是通过截断小数部分将浮点值转换为整型。 对浮点数进行舍入运算时，需要使用Math.round方法。当调用round的时候，仍然需要使用强制类型转换(int)。原因是round方法返回的结果为long类型，由于存在信息丢失的可能性，所以只有使用显式的强制类型转换才能够将long类型转换成int类型。 12345double xx = 9.997;int nxx = (int) xx;System.out.println(nxx); // prints 9int nxx2 = (int) Math.round(xx);System.out.println(nxx2); // prints 10 如果试图将一个数值从一种类型强制转换为另一种类型，而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值。如(byte)300的实际值为44。 3.5.5 结合赋值和运算符 可以在赋值中运用二元运算符，如x += 4;等价于x = x + 4;。 如果运算符得到一个值，其类型与左侧操作数的类型不同，就会发生强制类型转换。如果x是一个int，则x += 3.5;等价于x = (int)(x + 3.5);。 3.5.6 自增与自减运算符 自增运算符：n++，自减运算符：n–。 自增运算符还有一种“前缀”形式：++n。 后缀和前缀形式都会使变量值加1或减1。但用在表达式中时，二者就有区别了。前缀形式会先完成加1；而后缀形式会使用变量原来的值。 建议不要在表达式中使用++，因为这样的代码很容易让人困惑，而且会带来烦人的bug。 3.5.7 关系和boolean运算符 &amp;&amp;和||运算符是按照“短路”方式来求值的。 x != 0 &amp;&amp; 1 / x &gt; x + y // no division by 0，如果x等于0，那么第二部分就不会计算，除以0的错误就不会出现。 Java支持三元操作符?:，例如x &lt; y ? x : y返回x和y中较小的一个。 3.5.8 位运算符 如果n是一个整数变量，而且用二进制表示的n从右边数第4位为1，则int fourthBitFromRight = (n &amp; 0b1000) / 0b1000;会返回1，否则返回0. 利用&amp;并结合适当的2的幂，可以把其他位掩掉，而只留下其中的某一位。 &amp;和|运算符不采用“短路”方式求值。 需要建立位模式来完成掩码时，&gt;&gt;和&lt;&lt;运算符会很方便，int fourthBitFromRight = (n &amp; (1 &lt;&lt; 3)) &gt;&gt; 3;。 &gt;&gt;&gt;运算符会用0填充高位，这与&gt;&gt;不同，它会用符号位填充高位。 3.5.9 括号与运算符级别 注意+=是右结合运算符。 3.6 字符串 从概念上讲，Java字符串就是Unicode字符序列。 每个双引号括起来的字符串都是String类的一个实例。 3.6.1 子串 String类的substring方法可以从一个较大的字符串中提取出一个子串。 12345678public class SubString &#123; public static void main(String[] args) &#123; String greeting = &quot;Hello&quot;; String s = greeting.substring(0, 3); System.out.println(s); // prints Hel &#125;&#125; substring方法的第二个参数是不想复制的第一个位置。这样的工作方式有一个优点，容易计算子串的长度。字符串s.substring(a,b)的长度为b-a。 3.6.2 拼接 Java语言允许使用+号连接两个字符串。 当一个字符串与一个非字符串的值进行拼接时，后者会转换成字符串。 如果需要把多个字符串放在一起，用一个界定符分隔，可以使用静态join方法。 在Java11中，提供了一个repeat方法。 12System.out.println(String.join(&quot;/&quot;, &quot;S&quot;, &quot;M&quot;, &quot;L&quot;)); // prints S/M/LSystem.out.println(&quot;Java&quot;.repeat(3)); // prints JavaJavaJava 3.6.3 不可变字符串 如何修改字符串？可以提取想要保留的子串，再与希望替换的字符拼接,greeting = greeting.substring(0, 3) + &quot;p!&quot;;。 由于不能修改Java字符串中的单个字符，所以在Java文档中将String类对象称为是不可变的，但是，可以修改字符串变量。 不可变字符串有一个优点：编译器可以让字符串共享。 3.6.4 检测字符串是否相等 s.equals(t)检测两个字符串是否相等，s与t可以是字符串变量，也可以是字符串字面量，例如&quot;Hello&quot;.equals(greeting)。 检测两个字符串是否相等，而不区分大小写 1&quot;Hello&quot;.equalsIgnoreCase(&quot;hello&quot;) 一定不要使用==运算检测两个字符串是否相等！这个运算符只能够确定两个字符串是否存放在同一个位置上。 3.6.5 空串与Null串 空串&quot;&quot;是长度为0的字符串，有自己的串长度（0）和内容（空）。检查一个字符串是否为空： 1if(str.length() == 0) 1if(str.equals(&quot;&quot;)) null，表示目前没有任何对象与该变量关联。检查一个字符串是否为null： 1if(str == null) 检查一个字符串既不是null也不是空串，需要首先检查str不为null。 1if(str != null &amp;&amp; str.length() != 0) 3.6.6 码点与代码单元 要想得到实际的长度，即码点数量，可以调用： 1int cpCount = greeting.codePointCount(0, greeting.length()); 3.6.9 构建字符串 如果需要许多小段的字符串来构建一个字符串，按照下列步骤进行。 1234StringBuilder builder = new StringBuilder();builder.append(ch); // appends a single characterbuilder.append(str); // appends a stringString completedString = builder.toString();","tags":[{"name":"《Java核心技术卷I 基础知识》","slug":"《Java核心技术卷I-基础知识》","permalink":"http://example.com/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%8B/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"3.1一个简单的Java应用程序-3.4 变量与常量","date":"2021-04-16T04:05:00.000Z","path":"2021/04/16/coreJava1/3.1一个简单的Java应用程序-3.4 变量与常量/","text":"3.1 一个简单的Java应用程序 123456public class FirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;We will not use &#x27;Hello, World!&quot;); &#125;&#125; Java是区分大小写的。 public为访问修饰符，用于控制程序的其他部分对这段代码的访问级别。 在Java中，应用程序中的全部内容都必须放置在类中。 类名的规则：名字必须以字母开头，后面可以跟字母和数字的任意组合，长度没有限制，但是不能使用Java保留字。 类名的命名方法，可采用骆驼命名法，类名以大写字母开头，如果名字由多个单词组成，每个单词的第一个字母应该大写，如CameClass。 Java虚拟机总是从指定类中的main方法的代码开始执行的。 每个Java应用程序都必须有一个main方法，声明格式如下 1234567public class ClassName&#123; public static void main(String[] args) &#123; program statements &#125;&#125; 在Java中一对大括号表示方法体的开始与结束，每个句子必须使用分号结束。 System.out.print(&quot;Hello&quot;)输出之后不增加换行符。 3.2 注释 Java中有三种注释方法： 使用//，注释内容从//开始到本行结尾。 使用/*和*/，这之间均为注释内容，可以注释更长的内容。 文档注释，以/**开始，以*/结束。 12345678910111213/** * This is the first sample program in Core Java CHapter 3 * @version 1.01 1997-03-22 * @author Gary Cornell */package firstsample;public class FirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;We will not use &#x27;Hello, World!&quot;); &#125;&#125; 3.3 数据类型 Java是一种强类型语言。在Java中，有8种基本数据类型，其中有4种整型、2种浮点类型、1种字符类型和1种用于表示真值的boolean类型。 3.3.1 整型 整型有4种类型。 类型 存储需求 取值范围 int 4字节 -2 147 483 648 ~ 2 147 483 647（刚刚超过20亿） short 2字节 -32 768 ~ 32 767 long 8字节 -9 223 372 036 854 775 808~9 223 372 036 854 775 807 byte 1字节 -128~127 byte和short类型主要用于特定的应用场合。 长整型数值有一个后缀L或l。例如如果直接运行System.out.println(4000000000000);会出现错误，提示The literal 4000000000000 of type int is out of range，这时要用到长整型数System.out.println(4000000000000L);。 十六进制数值有一个前缀0X或0x。 八进制有一个前缀0。 从Java7开始，加上前缀0b或0B可以写二进制。 3.3.2 浮点类型 Java中有两种浮点类型。 类型 存储需求 取值范围 float 4字节 大约 $\\pm$3.402 823 47E+38F(有效位数为6~7位) double 8字节 大约 $\\pm$1.797 693 134 862 315 70E+308(有效位数为15位) 实际上，只有很少的情况适合使用float类型，例如，需要单精度数的库，或者需要大量存储数据时。 float类型的数值有一个后缀F或f。没有后缀F的浮点数总是默认为double类型。 用于表示溢出和出错情况的三个特殊的浮点数值：正无穷大Double.POSITIVE_INFINITY、负无穷大Double.NEGATIVE_INFINITY、NaN（不是一个数字，常量表示为Double.NaN）。 检测一个特定值是否等于Double.NaN:if(Double.isNaN(x)) // check whether x is &quot;not a number&quot;。 特别注意：浮点数值不适用与无法接受舍入误差的金融计算，原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确地表示分数1/10。 3.3.3 char类型 char类型原本用于表示单个字符，如今，有些Unicode字符可以用一个或两个char值描述。 char类型的字面量值要用单引号括起来，例如‘A’是编码值为65的字符常量。 转义序列\\u还可以出现在加引号的字符常量和字符串之外（而其他所有的转义序列不可以）。 Unicode转义序列会在解析代码之前得到处理，因此一定要当心注释中的\\u。如// \\u000A is a newline会报错。 3.3.4 Unicode和char类型 不同编码机制产生了两个问题：一是对于任意给定的代码值，在不同的编码方案下有可能对应不同的字母；而是采用大字符集的语言其编码长度有可能不同。 在Java中，char类型描述了UTF-16编码中的一个代码单元。 强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。 3.3.5 boolean类型 boolean类型有两个值：false和true，用来判定逻辑条件。 整型值和布尔值之间不能进行转换。 3.4 变量与常量 3.4.1 声明变量 在Java中，每个变量都有一个类型。 声明变量的例子： 1234double salary;int vacationDays;long earthPopulation;boolean done; 变量名必须是一个以字母开头并由字母和数字构成的序列。 在Java中，“字母”和“数字”的范围更大。字母包括‘A’~‘Z’、‘a’~‘z’、‘_’、‘$’或在某种语言中表示字母的任何Unicode字符。数字包括‘0’~‘9’和在某种语言中表示数字的任何Unicode字符。 变量中所有字符都是有意义的，并且大小写敏感。 如果想知道哪些Unicode字符属于Java中的“字母”，可以使用Character类的isJavaIdentifierStart和isJavaIdentifierPart方法来检查。 不能使用Java保留字作为变量名。 在Java9中，单下划线不能作为变量名。 逐一声明每一个变量可以提高程序的可读性。 3.4.2 变量初始化 声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量的值。 有两种方式进行变量初始化： 12int vacationDays;vacationDays = 12; 1int vacationDays = 12; 在Java中可以将声明放在代码中的任何地方。 在Java中，变量的声明尽可能地靠近变量第一次使用的地方，这是一种良好的程序编程风格。 从Java10开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不再需要声明类型。只需要使用关键字var而无须指定类型。 1var vacationDays = 12; // vacationDays is an int 3.4.3 常量 关键字final表示这个变量只能被赋值一次。一旦赋值之后，就不能够再更改了。习惯上，常量名使用全大写。 12345678910 public class Constants &#123; public static void main(String[] args) &#123; final double CM_PER_INCH = 2.54; double paperWidth = 8.5; double paperHeight = 11; System.out.println(&quot;Paper size in centimeters: &quot; + paperWidth * CM_PER_INCH + &quot; by &quot; + paperHeight * CM_PER_INCH); &#125;&#125; 类常量，可以在一个类的多个方法中使用，使用关键字static final设置一个类常量。 1234567891011public class Constants2 &#123; public static final double CM_PER_INCH = 2.54; public static void main(String[] args) &#123; double paperWidth = 8.5; double paperHeight = 11; System.out.println(&quot;Paper size in centimeters: &quot; + paperWidth * CM_PER_INCH + &quot; by &quot; + paperHeight * CM_PER_INCH); &#125;&#125; 类常量的定义位于main方法的外部。如果一个类常量被声明为public，那么其他类的方法也可以使用这个常量。 3.4.4 枚举类型 枚举类型包括有限个命名的值。例如enum Size &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;。 Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者特殊值null，null表示这个变量没有设置任何值。 书籍信息 《Java核心技术卷I 基础知识》","tags":[{"name":"《Java核心技术卷I 基础知识》","slug":"《Java核心技术卷I-基础知识》","permalink":"http://example.com/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%8B/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"《算法》笔记1-1.1 Basic Programming Model","date":"2021-04-05T11:18:09.000Z","path":"2021/04/05/《算法》/《算法》笔记1-1.1 Basic Programming Model/","text":"Chapter 1 Fundamentals abstract data types(ADTs) applications programming interface(API) 1.1 Basic Programming Model Expressions (P13) 操作数之间的优先级 Java语言中：*和/（和%）比+和-的优先级高. 逻辑操作数中：!拥有最高优先级，接着是&amp;&amp;和||. 一般而言，相同优先级的操作数遵循从左到右的优先级。 由于在语言之间优先级有轻微的差别，可以使用括号来避免。 Type conversion（类型转换）(P13) Numbers are automatically promoted to a more inclusive type if no information is lost. 在没有信息丢失的情况下，数字自动提高到一个包含更多的类型。 A cast is a type name in parentheses within an expression… 可以在表达式中加括号进行类型转换，例如(int) 3.7，结果为3。 Note that casting to an int is truncation instead of rounding… 特别注意的一点：转换为int类型时是截断而不是凑整。 A best practice is to use expressions that involve literals or variables of a single type. Comparisons (P13) 比较两个相同类型的值，返回一个布尔值。 name operator equal == not equal != less than &lt; less than or equal &lt;= greater than &gt; greater than or equal &gt;= Other primmitive types (P13) 64-bit integers, with arithmetic operations(long) 16-bit integers, with arithmetic operations(short) 16-bit characters, with arithmetic operations(char) 8-bit intergers, with arithmetic operations(byte) 32-bit single-precision real numbers, again with arithmetic operations(float) Implict assignments (P16) i++与++i的区别？ a = i++ 它等价于 a = i ; i = i + 1; a = ++i 它等价于 i = i + 1; a = i; Creating and initalizing an array (P18) 创建一个数组包括以下三个步骤，缺一不可: Declare the array name and type. Create the array. Initialize the array values. long term 1234double[] a;a = new double[N];for(int i = 0; i &lt; N; i++) a[i] = 0.0; short term 1double[] a = new double[N]; intializing declaration 1int[] a = &#123;1, 2, 5, 7, 8, 10 &#125;; Using an array (P19) Once we create an array, its size is fixed. A program can refer to the length of an array a[] with the code a.length. Aliasing (P19) … an array name refers to the whole array–if we assign one array name to another, then both refer to the sanme array… Two-dimensional arrays (P19) an M-by-N array 1double[][] a = new double[M][N]; 12345double[][] a;a = new double[M][N];for(int i = 0; i &lt; M; i++) for(int j = 0; j &lt; N; j++) a[i][j] = 0.0; Invoking a static method (P22) A return statement terminates a static method, returning control to the caller. Typical implementations of static methods (P23) primality test（判断是否为素数） 素数是指除了1和它本身之外，不能被任何整数整除的数。 首先，如果一个数不是素数，那么它能写成两个因子乘积的形式，例如N=a∗bN = a * bN=a∗b，此时，aaa与bbb中肯定一个小于N\\sqrt{N}N​，另一个大于等于N\\sqrt{N}N​，因此只需判断NNN是否能被222~N\\sqrt{N}N​之间的是整除即可。 如果NNN不能被222~N\\sqrt{N}N​之间的数整除，则NNN为素数。 1234567public static boolean isPrime(int N)&#123; if(N &lt; 2) return false; for(int i = 2; i*i &lt;= N; i++) if(N % i == 0) return false; return true;&#125; square root(Newton’s method) 这里求解算术平方根用到的是牛顿迭代法。 先说一般的牛顿迭代法，现要求解非线性方程f(x)=0f(x)=0f(x)=0的根。将f(x)f(x)f(x)在xnx_nxn​处展开得： f(x)=f(xn)+f′(xn)(x−xn)+O((x−xn)2) f(x)=f(x_n)+f&#x27;(x_n)(x-x_n)+O({(x-x_n)}^2) f(x)=f(xn​)+f′(xn​)(x−xn​)+O((x−xn​)2) 截取线性部分，加之f(x)=0f(x)=0f(x)=0，移项可得x=xn−f(xn)f′(xn)x=x_n- \\frac{f(x_n)}{f&#x27;(x_n)}x=xn​−f′(xn​)f(xn​)​，因此下一个点可为xn+1=xn−f(xn)f′(xn)x_{n+1}=x_n- \\frac{f(x_n)}{f&#x27;(x_n)}xn+1​=xn​−f′(xn​)f(xn​)​。 在求解算术平方根中，f(c)=c2f(c)=c^2f(c)=c2，可得cn+1=cn−cn22cnc_{n+1}=c_n-\\frac{ {c_n}^2}{2c_n}cn+1​=cn​−2cn​cn​2​。？？？ 123456789public static double sqrt(double c)&#123; if(c &lt; 0) return Double.NaN; double err = 1e-15; double t = c; while (Math.abs(t - c/t) &gt; err * t) t = (c/t + t) / 2.0; return t;&#125; Recursion (P25) 在递归程序中三个重要的规则: The recursion has a base case–we always include a conditional statement as the first statement in the program that has a return. Recursive calls must address subproblems that are smaller in some sense, so that recursive calls converge to the base case. Recursive calls should not address subproblems that overlap. Input and output (P36) Words 单词 释义 P3 amenable adj.合适的 hypothese 假设 connectivity 连通性 P4 devise 设计 go hand in hand 手拉手地前进；紧密联系；息息相关 P5 reap vt. &amp; vi. 收割庄稼; 收获 occasion n. 场合；时机，机会；理由 vt. 引起，惹起 fraction n. 小部分；部分；稍微；[数]分数 tune n. 曲调, 曲子 vt. &amp; vi. 调音 vt. 调整 P6 comparative adj. 比较的, 相比的,相比之下的, 相比而言的, 相对的 indication n. 指示, 表示 P7 suffix array 后缀阵列 underpinning n. 基础,支柱,支撑 intricate adj. 错综复杂的 P8 concise adj. 简明的 downside adj. 下降趋势的 depict vt. 描绘; 描画 defer vt. 拖延, 延缓, 推迟vi. 服从某人的意愿, 遵从 annotation n. 注解,注释 idiom n. 成语，习语；土话 P9 anatomy n. 解剖, 解剖学,分析 encapsulate vt. 装入胶囊总结;扼要概括;囊括adj. 有(胶)囊包着的 P11 alphanumeric adj. 文字数字的,包括文字与数字的 manipulate vt. 熟练控制[操作] permissible adj. 可允许的, 许可的 primitive adj. 原始的, 早期的 literal adj. 逐字的；无夸张的；文字的 P13 infix vt. 使…钻进,让…插进n. 插入词,中缀 precedence n. 领先于…的权利;优先权 parentheses n. 圆括号,插入语,插曲 type conversion 类型转换 promote vt. 提升, 提拔〈正〉促进; 推动; 增进 cast vt. &amp; vi. 投, 掷, 扔,浇铸vt. 投射, 加…于分配(演戏剧等的)角色 intricate adj. 错综复杂的 sparingly adv. 节俭地;爱惜地;保守地;谨慎地 persist vi. 持续，固执；存留，坚持 P14 manipulate vt. 熟练控制[操作] curly brace 花括号 associate vt. &amp; vi. (使)发生联系, (使)联合; 结交, 结伙adj. 副的；联合的 a nested structure 嵌套结构 scope n. 视野；眼界；范围；余地；导弹射程 P15 template n. 模板 refrain vi. 制止；避免；节制，克制 self-explanatory adj. 不解自明的;明显的 P16 prepend vt. 预先考虑；预谋 operand n. [计]操作数；[数]运算对象 compactly adv. 细密地,简洁地 P18 unambiguously adv. 明白地,不含糊地 P19 comma n. 逗号；停顿 aliasing n. 别名使用；[数]混淆现象 ragged adj.参差不齐的, 凹凸不平的 superfluous adj. 过多的; 过剩的; 多余的 P22 encapsulate vt. 总结;扼要概括;囊括 side effect n. 副作用 semicolon n. 分号 terminate vt. &amp; vi. 结束; 使终结 P24 indicate vt. 标示, 指示, 指出 P25 succinct adj. 简洁的；简明的；紧身的 overlap n. 重叠；重复vi. 部分重叠；部分的同时发生 P27 scant adj. 不足的；缺乏的；勉强够的vt. 减少；节省；限制 P29 excerpt n. 摘录, 摘要vt. 选录, 摘录 delineate vt. 勾画,描述 P31 bedrock n. 根底；基岩；基本原理 overstate vt. 夸大(某事) articulate adj. 表达能力强的;口齿清楚的, 发音清晰的vt. &amp; vi. 清楚地表达 P33 substitute vt. &amp; vi. 代替, 替换, 代用 P34 concatenation n. 一系列互相关联的事物 conversion n. 变换, 转化 P35 paradigm n. 范例；词形变化表 P36 generic adj. 一般的；属的；类的；非商标的 书籍信息 《算法》","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://example.com/tags/Algorithms/"}]},{"title":"欧拉方法、隐式欧拉方法","date":"2021-03-11T07:11:09.000Z","path":"2021/03/11/微分方程数值解/欧拉方法、隐式欧拉方法/欧拉方法、隐式欧拉方法/","text":"求解如下常微分方程： {dudt=−ut,1≤t≤2u(1)=1\\begin{aligned} \\begin{cases} \\frac{du}{dt}=-\\frac{u}{t},1\\leq t\\leq 2\\\\ u(1)=1 \\end{cases} \\end{aligned} {dtdu​=−tu​,1≤t≤2u(1)=1​​ 精确解 将原方程化为tdu+udt=0tdu+udt=0tdu+udt=0，则有d(ut)=0d(ut)=0d(ut)=0，解得ut=Cut=Cut=C(CCC为常数)，代入初始条件得C=1C=1C=1，从而该方程的精确解为： u=1t,(1≤t≤2).\\begin{aligned} u=\\frac{1}{t},(1\\leq t \\leq2). \\end{aligned} u=t1​,(1≤t≤2).​ 欧拉方法 代入欧拉格式得： ui+1=ui+hf(ti,ui)=ui+h(−uiti)\\begin{aligned} u_{i+1}=u_{i}+hf(t_i,u_i)=u_i+h(-\\frac{u_i}{t_i}) \\end{aligned} ui+1​=ui​+hf(ti​,ui​)=ui​+h(−ti​ui​​)​ 隐式欧拉方法 由隐式欧拉格式得： ui+1=ui+hf(ti+1,ui+1)=ui+h(−ui+1ti+1)，\\begin{aligned} u_{i+1}=u_{i}+hf(t_{i+1},u_{i+1})=u_i+h(-\\frac{u_{i+1}}{t_{i+1}})， \\end{aligned} ui+1​=ui​+hf(ti+1​,ui+1​)=ui​+h(−ti+1​ui+1​​)，​ 移项化简可得： ui+1=ti+1uiti+1+h\\begin{aligned} u_{i+1}=\\frac{t_{i+1}u_i}{t_{i+1}+h} \\end{aligned} ui+1​=ti+1​+hti+1​ui​​​ 程序 根据上述推导，用python编写程序，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# implict euler methodimport numpy as npimport matplotlib.pyplot as plt# the right term of the ODEdef f(t, u): f = -u/t return f# the exact solution of ODE def fexact(t): fexact = 1/t return fexactN = 100t_n = 2.0dt = (t_n - 1.0) / Nt = np.arange(1.0, t_n + dt, dt)u_euler = np.arange(1.0, t_n + dt, dt)u = np.arange(1.0, t_n + dt, dt)u_true = np.arange(1.0, t_n + dt, dt)i = 0while i &lt; N: t[i+1] = t[i] + dt u_euler[i+1] = u_euler[i] + dt * f(t[i], u_euler[i]) u[i+1] = (u[i] * t[i+1])/(t[i+1] + dt) u_true[i+1] = fexact(t[i+1]) i = i + 1err_euler = max(abs(u_euler - u_true))err_implict_euler = max(abs(u - u_true))print(&quot;The error of euler method: &quot;,err_euler)print(&quot;The error of implict euler method: &quot;,err_implict_euler)# begin drawingplt.title(&#x27;Result&#x27;)plt.plot(t, u_euler, color=&#x27;green&#x27;, label=&#x27;euler&#x27;)plt.plot(t, u, color=&#x27;blue&#x27;, label=&#x27;implict euler&#x27;)plt.plot(t, u_true, color=&#x27;red&#x27;, label=&#x27;exact&#x27;)plt.legend() # show the legendplt.xlabel(&#x27;t&#x27;)plt.ylabel(&#x27;u&#x27;)plt.show() 结果分析 当取h=0.01h=0.01h=0.01时，此时欧拉方法的误差为0.02631578947368396，隐式欧拉方法的误差为0.023809523809523836，结果如下图所示： 当取不同hhh，得到的误差如下表所示： hhh 欧拉方法 隐式欧拉方法 12\\frac{1}{2}21​ 0.16666666666666663 0.09999999999999998 14\\frac{1}{4}41​ 0.0714285714285714 0.05555555555555558 18\\frac{1}{8}81​ 0.033333333333333215 0.02941176470588236 116\\frac{1}{16}161​ 0.01612903225806467 0.015151515151515138 132\\frac{1}{32}321​ 0.00793650793650813 0.007692307692307665 164\\frac{1}{64}641​ 0.0039370078740155193 0.003875968992248069","tags":[{"name":"数值分析","slug":"数值分析","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"},{"name":"微分方程数值解","slug":"微分方程数值解","permalink":"http://example.com/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%95%B0%E5%80%BC%E8%A7%A3/"},{"name":"欧拉方法","slug":"欧拉方法","permalink":"http://example.com/tags/%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95/"},{"name":"隐式欧拉方法","slug":"隐式欧拉方法","permalink":"http://example.com/tags/%E9%9A%90%E5%BC%8F%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95/"}]}]