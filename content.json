[{"title":"《算法》笔记1-1.1 Basic Programming Model","date":"2021-04-05T11:18:09.000Z","path":"2021/04/05/《算法》笔记1-1.1 Basic Programming Model/","text":"Chapter 1 Fundamentals abstract data types(ADTs) applications programming interface(API) 1.1 Basic Programming Model Expressions (P13) 操作数之间的优先级 Java语言中：*和/（和%）比+和-的优先级高. 逻辑操作数中：!拥有最高优先级，接着是&amp;&amp;和||. 一般而言，相同优先级的操作数遵循从左到右的优先级。 由于在语言之间优先级有轻微的差别，可以使用括号来避免。 Type conversion（类型转换）(P13) Numbers are automatically promoted to a more inclusive type if no information is lost. 在没有信息丢失的情况下，数字自动提高到一个包含更多的类型。 A cast is a type name in parentheses within an expression… 可以在表达式中加括号进行类型转换，例如(int) 3.7，结果为3。 Note that casting to an int is truncation instead of rounding… 特别注意的一点：转换为int类型时是截断而不是凑整。 A best practice is to use expressions that involve literals or variables of a single type. Comparisons (P13) 比较两个相同类型的值，返回一个布尔值。 name operator equal == not equal != less than &lt; less than or equal &lt;= greater than &gt; greater than or equal &gt;= Other primmitive types (P13) 64-bit integers, with arithmetic operations(long) 16-bit integers, with arithmetic operations(short) 16-bit characters, with arithmetic operations(char) 8-bit intergers, with arithmetic operations(byte) 32-bit single-precision real numbers, again with arithmetic operations(float) Implict assignments (P16) i与i的区别？ a = i++ 它等价于 a = i ; i = i + 1; a = ++i 它等价于 i = i + 1; a = i; Creating and initalizing an array (P18) 创建一个数组包括以下三个步骤，缺一不可: Declare the array name and type. Create the array. Initialize the array values. long term 1234double[] a;a = new double[N];for(int i = 0; i &lt; N; i++) a[i] = 0.0; short term 1double[] a = new double[N]; intializing declaration 1int[] a = &#123;1, 2, 5, 7, 8, 10 &#125;; Using an array (P19) Once we create an array, its size is fixed. A program can refer to the length of an array a[] with the code a.length. Aliasing (P19) … an array name refers to the whole array–if we assign one array name to another, then both refer to the sanme array… Two-dimensional arrays (P19) an M-by-N array 1double[][] a = new double[M][N]; 12345double[][] a;a = new double[M][N];for(int i = 0; i &lt; M; i++) for(int j = 0; j &lt; N; j++) a[i][j] = 0.0; Invoking a static method (P22) A return statement terminates a static method, returning control to the caller. Typical implementations of static methods (P23) primality test（判断是否为素数） 素数是指除了1和它本身之外，不能被任何整数整除的数。 首先，如果一个数不是素数，那么它能写成两个因子乘积的形式，例如N=a∗bN = a * bN=a∗b，此时，aaa与bbb中肯定一个小于N\\sqrt{N}N​，另一个大于等于N\\sqrt{N}N​，因此只需判断NNN是否能被222~N\\sqrt{N}N​之间的是整除即可。 如果NNN不能被222~N\\sqrt{N}N​之间的数整除，则NNN为素数。 1234567public static boolean isPrime(int N)&#123; if(N &lt; 2) return false; for(int i = 2; i*i &lt;= N; i++) if(N % i == 0) return false; return true;&#125; square root(Newton’s method) 这里求解算术平方根用到的是牛顿迭代法。 先说一般的牛顿迭代法，现要求解非线性方程f(x)=0f(x)=0f(x)=0的根。将f(x)f(x)f(x)在xnx_nxn​处展开得： f(x)=f(xn)+f′(xn)(x−xn)+O((x−xn)2) f(x)=f(x_n)+f&#x27;(x_n)(x-x_n)+O({(x-x_n)}^2) f(x)=f(xn​)+f′(xn​)(x−xn​)+O((x−xn​)2) 截取线性部分，加之f(x)=0f(x)=0f(x)=0，移项可得x=xn−f(xn)f′(xn)x=x_n- \\frac{f(x_n)}{f&#x27;(x_n)}x=xn​−f′(xn​)f(xn​)​，因此下一个点可为xn+1=xn−f(xn)f′(xn)x_{n+1}=x_n- \\frac{f(x_n)}{f&#x27;(x_n)}xn+1​=xn​−f′(xn​)f(xn​)​。 在求解算术平方根中，f(c)=c2f(c)=c^2f(c)=c2，可得cn+1=cn−cn22cnc_{n+1}=c_n-\\frac{ {c_n}^2}{2c_n}cn+1​=cn​−2cn​cn​2​。？？？ 123456789public static double sqrt(double c)&#123; if(c &lt; 0) return Double.NaN; double err = 1e-15; double t = c; while (Math.abs(t - c/t) &gt; err * t) t = (c/t + t) / 2.0; return t;&#125; Recursion (P25) 在递归程序中三个重要的规则: The recursion has a base case–we always include a conditional statement as the first statement in the program that has a return. Recursive calls must address subproblems that are smaller in some sense, so that recursive calls converge to the base case. Recursive calls should not address subproblems that overlap. Words 单词 释义 P3 amenable adj.合适的 hypothese 假设 connectivity 连通性 P4 devise 设计 go hand in hand 手拉手地前进；紧密联系；息息相关 P5 reap vt. &amp; vi. 收割庄稼; 收获 occasion n. 场合；时机，机会；理由 vt. 引起，惹起 fraction n. 小部分；部分；稍微；[数]分数 tune n. 曲调, 曲子 vt. &amp; vi. 调音 vt. 调整 P6 comparative adj. 比较的, 相比的,相比之下的, 相比而言的, 相对的 indication n. 指示, 表示 P7 suffix array 后缀阵列 underpinning n. 基础,支柱,支撑 intricate adj. 错综复杂的 P8 concise adj. 简明的 downside adj. 下降趋势的 depict vt. 描绘; 描画 defer vt. 拖延, 延缓, 推迟vi. 服从某人的意愿, 遵从 annotation n. 注解,注释 idiom n. 成语，习语；土话 P9 anatomy n. 解剖, 解剖学,分析 encapsulate vt. 装入胶囊总结;扼要概括;囊括adj. 有(胶)囊包着的 P11 alphanumeric adj. 文字数字的,包括文字与数字的 manipulate vt. 熟练控制[操作] permissible adj. 可允许的, 许可的 primitive adj. 原始的, 早期的 literal adj. 逐字的；无夸张的；文字的 P13 infix vt. 使…钻进,让…插进n. 插入词,中缀 precedence n. 领先于…的权利;优先权 parentheses n. 圆括号,插入语,插曲 type conversion 类型转换 promote vt. 提升, 提拔〈正〉促进; 推动; 增进 cast vt. &amp; vi. 投, 掷, 扔,浇铸vt. 投射, 加…于分配(演戏剧等的)角色 intricate adj. 错综复杂的 sparingly adv. 节俭地;爱惜地;保守地;谨慎地 persist vi. 持续，固执；存留，坚持 P14 manipulate vt. 熟练控制[操作] curly brace 花括号 associate vt. &amp; vi. (使)发生联系, (使)联合; 结交, 结伙adj. 副的；联合的 a nested structure 嵌套结构 scope n. 视野；眼界；范围；余地；导弹射程 P15 template n. 模板 refrain vi. 制止；避免；节制，克制 self-explanatory adj. 不解自明的;明显的 P16 prepend vt. 预先考虑；预谋 operand n. [计]操作数；[数]运算对象 compactly adv. 细密地,简洁地 P18 unambiguously adv. 明白地,不含糊地 P19 comma n. 逗号；停顿 aliasing n. 别名使用；[数]混淆现象 ragged adj.参差不齐的, 凹凸不平的 superfluous adj. 过多的; 过剩的; 多余的 P22 encapsulate vt. 总结;扼要概括;囊括 side effect n. 副作用 semicolon n. 分号 terminate vt. &amp; vi. 结束; 使终结 P24 indicate vt. 标示, 指示, 指出 P25 succinct adj. 简洁的；简明的；紧身的 overlap n. 重叠；重复vi. 部分重叠；部分的同时发生 P27 scant adj. 不足的；缺乏的；勉强够的vt. 减少；节省；限制 P29 excerpt n. 摘录, 摘要vt. 选录, 摘录 delineate vt. 勾画,描述 P31 bedrock n. 根底；基岩；基本原理 overstate vt. 夸大(某事) articulate adj. 表达能力强的;口齿清楚的, 发音清晰的vt. &amp; vi. 清楚地表达 P33 substitute vt. &amp; vi. 代替, 替换, 代用 P34 concatenation n. 一系列互相关联的事物 conversion n. 变换, 转化 P35 paradigm n. 范例；词形变化表 书籍信息 《算法》","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://example.com/tags/Algorithms/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"欧拉方法、隐式欧拉方法","date":"2021-03-11T10:43:09.000Z","path":"2021/03/11/欧拉方法、隐式欧拉方法/","text":"求解如下常微分方程： {dudt=−ut,1≤t≤2u(1)=1\\begin{aligned} \\begin{cases} \\frac{du}{dt}=-\\frac{u}{t},1\\leq t\\leq 2\\\\ u(1)=1 \\end{cases} \\end{aligned} {dtdu​=−tu​,1≤t≤2u(1)=1​​ 精确解 将原方程化为tdu+udt=0tdu+udt=0tdu+udt=0，则有d(ut)=0d(ut)=0d(ut)=0，解得ut=Cut=Cut=C(CCC为常数)，代入初始条件得C=1C=1C=1，从而该方程的精确解为： u=1t,(1≤t≤2).\\begin{aligned} u=\\frac{1}{t},(1\\leq t \\leq2). \\end{aligned} u=t1​,(1≤t≤2).​ 欧拉方法 代入欧拉格式得： ui+1=ui+hf(ti,ui)=ui+h(−uiti)\\begin{aligned} u_{i+1}=u_{i}+hf(t_i,u_i)=u_i+h(-\\frac{u_i}{t_i}) \\end{aligned} ui+1​=ui​+hf(ti​,ui​)=ui​+h(−ti​ui​​)​ 隐式欧拉方法 由隐式欧拉格式得： ui+1=ui+hf(ti+1,ui+1)=ui+h(−ui+1ti+1)，\\begin{aligned} u_{i+1}=u_{i}+hf(t_{i+1},u_{i+1})=u_i+h(-\\frac{u_{i+1}}{t_{i+1}})， \\end{aligned} ui+1​=ui​+hf(ti+1​,ui+1​)=ui​+h(−ti+1​ui+1​​)，​ 移项化简可得： ui+1=ti+1uiti+1+h\\begin{aligned} u_{i+1}=\\frac{t_{i+1}u_i}{t_{i+1}+h} \\end{aligned} ui+1​=ti+1​+hti+1​ui​​​ 程序 根据上述推导，用python编写程序，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# implict euler methodimport numpy as npimport matplotlib.pyplot as plt# the right term of the ODEdef f(t, u): f = -u/t return f# the exact solution of ODE def fexact(t): fexact = 1/t return fexactN = 100t_n = 2.0dt = (t_n - 1.0) / Nt = np.arange(1.0, t_n + dt, dt)u_euler = np.arange(1.0, t_n + dt, dt)u = np.arange(1.0, t_n + dt, dt)u_true = np.arange(1.0, t_n + dt, dt)i = 0while i &lt; N: t[i+1] = t[i] + dt u_euler[i+1] = u_euler[i] + dt * f(t[i], u_euler[i]) u[i+1] = (u[i] * t[i+1])/(t[i+1] + dt) u_true[i+1] = fexact(t[i+1]) i = i + 1err_euler = max(abs(u_euler - u_true))err_implict_euler = max(abs(u - u_true))print(&quot;The error of euler method: &quot;,err_euler)print(&quot;The error of implict euler method: &quot;,err_implict_euler)# begin drawingplt.title(&#x27;Result&#x27;)plt.plot(t, u_euler, color=&#x27;green&#x27;, label=&#x27;euler&#x27;)plt.plot(t, u, color=&#x27;blue&#x27;, label=&#x27;implict euler&#x27;)plt.plot(t, u_true, color=&#x27;red&#x27;, label=&#x27;exact&#x27;)plt.legend() # show the legendplt.xlabel(&#x27;t&#x27;)plt.ylabel(&#x27;u&#x27;)plt.show() 结果分析 当取h=0.01h=0.01h=0.01时，此时欧拉方法的误差为0.02631578947368396，隐式欧拉方法的误差为0.023809523809523836，结果如下图所示： 当取不同hhh，得到的误差如下表所示： hhh 欧拉方法 隐式欧拉方法 12\\frac{1}{2}21​ 0.16666666666666663 0.09999999999999998 14\\frac{1}{4}41​ 0.0714285714285714 0.05555555555555558 18\\frac{1}{8}81​ 0.033333333333333215 0.02941176470588236 116\\frac{1}{16}161​ 0.01612903225806467 0.015151515151515138 132\\frac{1}{32}321​ 0.00793650793650813 0.007692307692307665 164\\frac{1}{64}641​ 0.0039370078740155193 0.003875968992248069","tags":[{"name":"欧拉方法","slug":"欧拉方法","permalink":"http://example.com/tags/%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95/"},{"name":"隐式欧拉方法","slug":"隐式欧拉方法","permalink":"http://example.com/tags/%E9%9A%90%E5%BC%8F%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95/"},{"name":"数值分析","slug":"数值分析","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"},{"name":"微分方程数值解","slug":"微分方程数值解","permalink":"http://example.com/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%95%B0%E5%80%BC%E8%A7%A3/"}]}]