[{"title":"【笔记】3.1一个简单的Java应用程序-3.4 变量与常量","date":"2021-04-16T04:05:00.000Z","path":"2021/04/16/coreJava1/【笔记】3.1一个简单的Java应用程序-3.4 变量与常量/","text":"3.1 一个简单的Java应用程序 123456public class FirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;We will not use &#x27;Hello, World!&quot;); &#125;&#125; Java是区分大小写的。 public为访问修饰符，用于控制程序的其他部分对这段代码的访问级别。 在Java中，应用程序中的全部内容都必须放置在类中。 类名的规则：名字必须以字母开头，后面可以跟字母和数字的任意组合，长度没有限制，但是不能使用Java保留字。 类名的命名方法，可采用骆驼命名法，类名以大写字母开头，如果名字由多个单词组成，每个单词的第一个字母应该大写，如CameClass。 Java虚拟机总是从指定类中的main方法的代码开始执行的。 每个Java应用程序都必须有一个main方法，声明格式如下 1234567public class ClassName&#123; public static void main(String[] args) &#123; program statements &#125;&#125; 在Java中一对大括号表示方法体的开始与结束，每个句子必须使用分号结束。 System.out.print(&quot;Hello&quot;)输出之后不增加换行符。 3.2 注释 Java中有三种注释方法： 使用//，注释内容从//开始到本行结尾。 使用/*和*/，这之间均为注释内容，可以注释更长的内容。 文档注释，以/**开始，以*/结束。 12345678910111213/** * This is the first sample program in Core Java CHapter 3 * @version 1.01 1997-03-22 * @author Gary Cornell */package firstsample;public class FirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;We will not use &#x27;Hello, World!&quot;); &#125;&#125; 3.3 数据类型 Java是一种强类型语言。在Java中，有8种基本数据类型，其中有4种整型、2种浮点类型、1种字符类型和1种用于表示真值的boolean类型。 3.3.1 整型 整型有4种类型。 类型 存储需求 取值范围 int 4字节 -2 147 483 648 ~ 2 147 483 647（刚刚超过20亿） short 2字节 -32 768 ~ 32 767 long 8字节 -9 223 372 036 854 775 808~9 223 372 036 854 775 807 byte 1字节 -128~127 byte和short类型主要用于特定的应用场合。 长整型数值有一个后缀L或l。例如如果直接运行System.out.println(4000000000000);会出现错误，提示The literal 4000000000000 of type int is out of range，这时要用到长整型数System.out.println(4000000000000L);。 十六进制数值有一个前缀0X或0x。 八进制有一个前缀0。 从Java7开始，加上前缀0b或0B可以写二进制。 3.3.2 浮点类型 Java中有两种浮点类型。 类型 存储需求 取值范围 float 4字节 大约 $\\pm$3.402 823 47E+38F(有效位数为6~7位) double 8字节 大约 $\\pm$1.797 693 134 862 315 70E+308(有效位数为15位) 实际上，只有很少的情况适合使用float类型，例如，需要单精度数的库，或者需要大量存储数据时。 float类型的数值有一个后缀F或f。没有后缀F的浮点数总是默认为double类型。 用于表示溢出和出错情况的三个特殊的浮点数值：正无穷大Double.POSITIVE_INFINITY、负无穷大Double.NEGATIVE_INFINITY、NaN（不是一个数字，常量表示为Double.NaN）。 检测一个特定值是否等于Double.NaN:if(Double.isNaN(x)) // check whether x is &quot;not a number&quot;。 特别注意：浮点数值不适用与无法接受舍入误差的金融计算，原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确地表示分数1/10。 3.3.3 char类型 char类型原本用于表示单个字符，如今，有些Unicode字符可以用一个或两个char值描述。 char类型的字面量值要用单引号括起来，例如‘A’是编码值为65的字符常量。 转义序列\\u还可以出现在加引号的字符常量和字符串之外（而其他所有的转义序列不可以）。 Unicode转义序列会在解析代码之前得到处理，因此一定要当心注释中的\\u。如// \\u000A is a newline会报错。 3.3.4 Unicode和char类型 不同编码机制产生了两个问题：一是对于任意给定的代码值，在不同的编码方案下有可能对应不同的字母；而是采用大字符集的语言其编码长度有可能不同。 在Java中，char类型描述了UTF-16编码中的一个代码单元。 强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。 3.3.5 boolean类型 boolean类型有两个值：false和true，用来判定逻辑条件。 整型值和布尔值之间不能进行转换。 3.4 变量与常量 3.4.1 声明变量 在Java中，每个变量都有一个类型。 声明变量的例子： 1234double salary;int vacationDays;long earthPopulation;boolean done; 变量名必须是一个以字母开头并由字母和数字构成的序列。 在Java中，“字母”和“数字”的范围更大。字母包括‘A’~‘Z’、‘a’~‘z’、‘_’、‘$’或在某种语言中表示字母的任何Unicode字符。数字包括‘0’~‘9’和在某种语言中表示数字的任何Unicode字符。 变量中所有字符都是有意义的，并且大小写敏感。 如果想知道哪些Unicode字符属于Java中的“字母”，可以使用Character类的isJavaIdentifierStart和isJavaIdentifierPart方法来检查。 不能使用Java保留字作为变量名。 在Java9中，单下划线不能作为变量名。 逐一声明每一个变量可以提高程序的可读性。 3.4.2 变量初始化 声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量的值。 有两种方式进行变量初始化： 12int vacationDays;vacationDays = 12; 1int vacationDays = 12; 在Java中可以将声明放在代码中的任何地方。 在Java中，变量的声明尽可能地靠近变量第一次使用的地方，这是一种良好的程序编程风格。 从Java10开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不再需要声明类型。只需要使用关键字var而无须指定类型。 1var vacationDays = 12; // vacationDays is an int 3.4.3 常量 关键字final表示这个变量只能被赋值一次。一旦赋值之后，就不能够再更改了。习惯上，常量名使用全大写。 12345678910 public class Constants &#123; public static void main(String[] args) &#123; final double CM_PER_INCH = 2.54; double paperWidth = 8.5; double paperHeight = 11; System.out.println(&quot;Paper size in centimeters: &quot; + paperWidth * CM_PER_INCH + &quot; by &quot; + paperHeight * CM_PER_INCH); &#125;&#125; 类常量，可以在一个类的多个方法中使用，使用关键字static final设置一个类常量。 1234567891011public class Constants2 &#123; public static final double CM_PER_INCH = 2.54; public static void main(String[] args) &#123; double paperWidth = 8.5; double paperHeight = 11; System.out.println(&quot;Paper size in centimeters: &quot; + paperWidth * CM_PER_INCH + &quot; by &quot; + paperHeight * CM_PER_INCH); &#125;&#125; 类常量的定义位于main方法的外部。如果一个类常量被声明为public，那么其他类的方法也可以使用这个常量。 3.4.4 枚举类型 枚举类型包括有限个命名的值。例如enum Size &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;。 Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者特殊值null，null表示这个变量没有设置任何值。 书籍信息 《Java核心技术卷I 基础知识》","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"《Java核心技术卷I 基础知识》","slug":"《Java核心技术卷I-基础知识》","permalink":"http://example.com/tags/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%8B/"}]},{"title":"《算法》笔记1-1.1 Basic Programming Model","date":"2021-04-05T11:18:09.000Z","path":"2021/04/05/《算法》/《算法》笔记1-1.1 Basic Programming Model/","text":"Chapter 1 Fundamentals abstract data types(ADTs) applications programming interface(API) 1.1 Basic Programming Model Expressions (P13) 操作数之间的优先级 Java语言中：*和/（和%）比+和-的优先级高. 逻辑操作数中：!拥有最高优先级，接着是&amp;&amp;和||. 一般而言，相同优先级的操作数遵循从左到右的优先级。 由于在语言之间优先级有轻微的差别，可以使用括号来避免。 Type conversion（类型转换）(P13) Numbers are automatically promoted to a more inclusive type if no information is lost. 在没有信息丢失的情况下，数字自动提高到一个包含更多的类型。 A cast is a type name in parentheses within an expression… 可以在表达式中加括号进行类型转换，例如(int) 3.7，结果为3。 Note that casting to an int is truncation instead of rounding… 特别注意的一点：转换为int类型时是截断而不是凑整。 A best practice is to use expressions that involve literals or variables of a single type. Comparisons (P13) 比较两个相同类型的值，返回一个布尔值。 name operator equal == not equal != less than &lt; less than or equal &lt;= greater than &gt; greater than or equal &gt;= Other primmitive types (P13) 64-bit integers, with arithmetic operations(long) 16-bit integers, with arithmetic operations(short) 16-bit characters, with arithmetic operations(char) 8-bit intergers, with arithmetic operations(byte) 32-bit single-precision real numbers, again with arithmetic operations(float) Implict assignments (P16) i++与++i的区别？ a = i++ 它等价于 a = i ; i = i + 1; a = ++i 它等价于 i = i + 1; a = i; Creating and initalizing an array (P18) 创建一个数组包括以下三个步骤，缺一不可: Declare the array name and type. Create the array. Initialize the array values. long term 1234double[] a;a = new double[N];for(int i = 0; i &lt; N; i++) a[i] = 0.0; short term 1double[] a = new double[N]; intializing declaration 1int[] a = &#123;1, 2, 5, 7, 8, 10 &#125;; Using an array (P19) Once we create an array, its size is fixed. A program can refer to the length of an array a[] with the code a.length. Aliasing (P19) … an array name refers to the whole array–if we assign one array name to another, then both refer to the sanme array… Two-dimensional arrays (P19) an M-by-N array 1double[][] a = new double[M][N]; 12345double[][] a;a = new double[M][N];for(int i = 0; i &lt; M; i++) for(int j = 0; j &lt; N; j++) a[i][j] = 0.0; Invoking a static method (P22) A return statement terminates a static method, returning control to the caller. Typical implementations of static methods (P23) primality test（判断是否为素数） 素数是指除了1和它本身之外，不能被任何整数整除的数。 首先，如果一个数不是素数，那么它能写成两个因子乘积的形式，例如N=a∗bN = a * bN=a∗b，此时，aaa与bbb中肯定一个小于N\\sqrt{N}N​，另一个大于等于N\\sqrt{N}N​，因此只需判断NNN是否能被222~N\\sqrt{N}N​之间的是整除即可。 如果NNN不能被222~N\\sqrt{N}N​之间的数整除，则NNN为素数。 1234567public static boolean isPrime(int N)&#123; if(N &lt; 2) return false; for(int i = 2; i*i &lt;= N; i++) if(N % i == 0) return false; return true;&#125; square root(Newton’s method) 这里求解算术平方根用到的是牛顿迭代法。 先说一般的牛顿迭代法，现要求解非线性方程f(x)=0f(x)=0f(x)=0的根。将f(x)f(x)f(x)在xnx_nxn​处展开得： f(x)=f(xn)+f′(xn)(x−xn)+O((x−xn)2) f(x)=f(x_n)+f&#x27;(x_n)(x-x_n)+O({(x-x_n)}^2) f(x)=f(xn​)+f′(xn​)(x−xn​)+O((x−xn​)2) 截取线性部分，加之f(x)=0f(x)=0f(x)=0，移项可得x=xn−f(xn)f′(xn)x=x_n- \\frac{f(x_n)}{f&#x27;(x_n)}x=xn​−f′(xn​)f(xn​)​，因此下一个点可为xn+1=xn−f(xn)f′(xn)x_{n+1}=x_n- \\frac{f(x_n)}{f&#x27;(x_n)}xn+1​=xn​−f′(xn​)f(xn​)​。 在求解算术平方根中，f(c)=c2f(c)=c^2f(c)=c2，可得cn+1=cn−cn22cnc_{n+1}=c_n-\\frac{ {c_n}^2}{2c_n}cn+1​=cn​−2cn​cn​2​。？？？ 123456789public static double sqrt(double c)&#123; if(c &lt; 0) return Double.NaN; double err = 1e-15; double t = c; while (Math.abs(t - c/t) &gt; err * t) t = (c/t + t) / 2.0; return t;&#125; Recursion (P25) 在递归程序中三个重要的规则: The recursion has a base case–we always include a conditional statement as the first statement in the program that has a return. Recursive calls must address subproblems that are smaller in some sense, so that recursive calls converge to the base case. Recursive calls should not address subproblems that overlap. Input and output (P36) Words 单词 释义 P3 amenable adj.合适的 hypothese 假设 connectivity 连通性 P4 devise 设计 go hand in hand 手拉手地前进；紧密联系；息息相关 P5 reap vt. &amp; vi. 收割庄稼; 收获 occasion n. 场合；时机，机会；理由 vt. 引起，惹起 fraction n. 小部分；部分；稍微；[数]分数 tune n. 曲调, 曲子 vt. &amp; vi. 调音 vt. 调整 P6 comparative adj. 比较的, 相比的,相比之下的, 相比而言的, 相对的 indication n. 指示, 表示 P7 suffix array 后缀阵列 underpinning n. 基础,支柱,支撑 intricate adj. 错综复杂的 P8 concise adj. 简明的 downside adj. 下降趋势的 depict vt. 描绘; 描画 defer vt. 拖延, 延缓, 推迟vi. 服从某人的意愿, 遵从 annotation n. 注解,注释 idiom n. 成语，习语；土话 P9 anatomy n. 解剖, 解剖学,分析 encapsulate vt. 装入胶囊总结;扼要概括;囊括adj. 有(胶)囊包着的 P11 alphanumeric adj. 文字数字的,包括文字与数字的 manipulate vt. 熟练控制[操作] permissible adj. 可允许的, 许可的 primitive adj. 原始的, 早期的 literal adj. 逐字的；无夸张的；文字的 P13 infix vt. 使…钻进,让…插进n. 插入词,中缀 precedence n. 领先于…的权利;优先权 parentheses n. 圆括号,插入语,插曲 type conversion 类型转换 promote vt. 提升, 提拔〈正〉促进; 推动; 增进 cast vt. &amp; vi. 投, 掷, 扔,浇铸vt. 投射, 加…于分配(演戏剧等的)角色 intricate adj. 错综复杂的 sparingly adv. 节俭地;爱惜地;保守地;谨慎地 persist vi. 持续，固执；存留，坚持 P14 manipulate vt. 熟练控制[操作] curly brace 花括号 associate vt. &amp; vi. (使)发生联系, (使)联合; 结交, 结伙adj. 副的；联合的 a nested structure 嵌套结构 scope n. 视野；眼界；范围；余地；导弹射程 P15 template n. 模板 refrain vi. 制止；避免；节制，克制 self-explanatory adj. 不解自明的;明显的 P16 prepend vt. 预先考虑；预谋 operand n. [计]操作数；[数]运算对象 compactly adv. 细密地,简洁地 P18 unambiguously adv. 明白地,不含糊地 P19 comma n. 逗号；停顿 aliasing n. 别名使用；[数]混淆现象 ragged adj.参差不齐的, 凹凸不平的 superfluous adj. 过多的; 过剩的; 多余的 P22 encapsulate vt. 总结;扼要概括;囊括 side effect n. 副作用 semicolon n. 分号 terminate vt. &amp; vi. 结束; 使终结 P24 indicate vt. 标示, 指示, 指出 P25 succinct adj. 简洁的；简明的；紧身的 overlap n. 重叠；重复vi. 部分重叠；部分的同时发生 P27 scant adj. 不足的；缺乏的；勉强够的vt. 减少；节省；限制 P29 excerpt n. 摘录, 摘要vt. 选录, 摘录 delineate vt. 勾画,描述 P31 bedrock n. 根底；基岩；基本原理 overstate vt. 夸大(某事) articulate adj. 表达能力强的;口齿清楚的, 发音清晰的vt. &amp; vi. 清楚地表达 P33 substitute vt. &amp; vi. 代替, 替换, 代用 P34 concatenation n. 一系列互相关联的事物 conversion n. 变换, 转化 P35 paradigm n. 范例；词形变化表 P36 generic adj. 一般的；属的；类的；非商标的 书籍信息 《算法》","tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://example.com/tags/Algorithms/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"欧拉方法、隐式欧拉方法","date":"2021-03-11T10:43:09.000Z","path":"2021/03/11/微分方程数值解/欧拉方法、隐式欧拉方法/","text":"求解如下常微分方程： {dudt=−ut,1≤t≤2u(1)=1\\begin{aligned} \\begin{cases} \\frac{du}{dt}=-\\frac{u}{t},1\\leq t\\leq 2\\\\ u(1)=1 \\end{cases} \\end{aligned} {dtdu​=−tu​,1≤t≤2u(1)=1​​ 精确解 将原方程化为tdu+udt=0tdu+udt=0tdu+udt=0，则有d(ut)=0d(ut)=0d(ut)=0，解得ut=Cut=Cut=C(CCC为常数)，代入初始条件得C=1C=1C=1，从而该方程的精确解为： u=1t,(1≤t≤2).\\begin{aligned} u=\\frac{1}{t},(1\\leq t \\leq2). \\end{aligned} u=t1​,(1≤t≤2).​ 欧拉方法 代入欧拉格式得： ui+1=ui+hf(ti,ui)=ui+h(−uiti)\\begin{aligned} u_{i+1}=u_{i}+hf(t_i,u_i)=u_i+h(-\\frac{u_i}{t_i}) \\end{aligned} ui+1​=ui​+hf(ti​,ui​)=ui​+h(−ti​ui​​)​ 隐式欧拉方法 由隐式欧拉格式得： ui+1=ui+hf(ti+1,ui+1)=ui+h(−ui+1ti+1)，\\begin{aligned} u_{i+1}=u_{i}+hf(t_{i+1},u_{i+1})=u_i+h(-\\frac{u_{i+1}}{t_{i+1}})， \\end{aligned} ui+1​=ui​+hf(ti+1​,ui+1​)=ui​+h(−ti+1​ui+1​​)，​ 移项化简可得： ui+1=ti+1uiti+1+h\\begin{aligned} u_{i+1}=\\frac{t_{i+1}u_i}{t_{i+1}+h} \\end{aligned} ui+1​=ti+1​+hti+1​ui​​​ 程序 根据上述推导，用python编写程序，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# implict euler methodimport numpy as npimport matplotlib.pyplot as plt# the right term of the ODEdef f(t, u): f = -u/t return f# the exact solution of ODE def fexact(t): fexact = 1/t return fexactN = 100t_n = 2.0dt = (t_n - 1.0) / Nt = np.arange(1.0, t_n + dt, dt)u_euler = np.arange(1.0, t_n + dt, dt)u = np.arange(1.0, t_n + dt, dt)u_true = np.arange(1.0, t_n + dt, dt)i = 0while i &lt; N: t[i+1] = t[i] + dt u_euler[i+1] = u_euler[i] + dt * f(t[i], u_euler[i]) u[i+1] = (u[i] * t[i+1])/(t[i+1] + dt) u_true[i+1] = fexact(t[i+1]) i = i + 1err_euler = max(abs(u_euler - u_true))err_implict_euler = max(abs(u - u_true))print(&quot;The error of euler method: &quot;,err_euler)print(&quot;The error of implict euler method: &quot;,err_implict_euler)# begin drawingplt.title(&#x27;Result&#x27;)plt.plot(t, u_euler, color=&#x27;green&#x27;, label=&#x27;euler&#x27;)plt.plot(t, u, color=&#x27;blue&#x27;, label=&#x27;implict euler&#x27;)plt.plot(t, u_true, color=&#x27;red&#x27;, label=&#x27;exact&#x27;)plt.legend() # show the legendplt.xlabel(&#x27;t&#x27;)plt.ylabel(&#x27;u&#x27;)plt.show() 结果分析 当取h=0.01h=0.01h=0.01时，此时欧拉方法的误差为0.02631578947368396，隐式欧拉方法的误差为0.023809523809523836，结果如下图所示： 当取不同hhh，得到的误差如下表所示： hhh 欧拉方法 隐式欧拉方法 12\\frac{1}{2}21​ 0.16666666666666663 0.09999999999999998 14\\frac{1}{4}41​ 0.0714285714285714 0.05555555555555558 18\\frac{1}{8}81​ 0.033333333333333215 0.02941176470588236 116\\frac{1}{16}161​ 0.01612903225806467 0.015151515151515138 132\\frac{1}{32}321​ 0.00793650793650813 0.007692307692307665 164\\frac{1}{64}641​ 0.0039370078740155193 0.003875968992248069","tags":[{"name":"欧拉方法","slug":"欧拉方法","permalink":"http://example.com/tags/%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95/"},{"name":"隐式欧拉方法","slug":"隐式欧拉方法","permalink":"http://example.com/tags/%E9%9A%90%E5%BC%8F%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95/"},{"name":"数值分析","slug":"数值分析","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"},{"name":"微分方程数值解","slug":"微分方程数值解","permalink":"http://example.com/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%95%B0%E5%80%BC%E8%A7%A3/"}]}]